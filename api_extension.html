<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
  <!--
        This file is autogenerated from docs/api_extension.rst
        Do not edit this file. Changes will be lost.
      -->
  <!--
        This page was generated at Wed Apr 19 07:14:27 2023 UTC.
      -->
  <head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <link rel="stylesheet" type="text/css" href="css/main.css"/>
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/>
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/>
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/>
    <link rel="manifest" href="/manifest.json"/>
    <meta name="theme-color" content="#ffffff"/>
    <title>libvirt: Implementing a new API in Libvirt</title>
    <meta name="description" content="libvirt, virtualization, virtualization API"/>
    <script type="text/javascript" src="js/main.js">
      <!--// forces non-empty element-->
    </script>
  </head>
  <body onload="pageload()">
    <div id="body">
      <div class="document" id="implementing-a-new-api-in-libvirt">
<h1>Implementing a new API in Libvirt</h1>

<div class="contents topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#defining-the-public-api" id="id1">Defining the public API</a></p></li>
<li><p><a class="reference internal" href="#defining-the-internal-api" id="id2">Defining the internal API</a></p></li>
<li><p><a class="reference internal" href="#implementing-the-public-api" id="id3">Implementing the public API</a></p></li>
<li><p><a class="reference internal" href="#implementing-the-remote-protocol" id="id4">Implementing the remote protocol</a></p>
<ul>
<li><p><a class="reference internal" href="#defining-the-wire-protocol-format" id="id5">Defining the wire protocol format</a></p></li>
<li><p><a class="reference internal" href="#implement-the-rpc-client" id="id6">Implement the RPC client</a></p></li>
<li><p><a class="reference internal" href="#implement-the-server-side-dispatcher" id="id7">Implement the server side dispatcher</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#use-the-new-api-internally" id="id8">Use the new API internally</a></p></li>
<li><p><a class="reference internal" href="#expose-the-new-api-in-virsh" id="id9">Expose the new API in virsh</a></p></li>
<li><p><a class="reference internal" href="#implement-the-driver-methods" id="id10">Implement the driver methods</a></p>
<ul>
<li><p><a class="reference internal" href="#implement-common-handling" id="id11">Implement common handling</a></p></li>
<li><p><a class="reference internal" href="#implement-driver-handling" id="id12">Implement driver handling</a></p></li>
</ul>
</li>
</ul>
</div>
<p>This document walks you through the process of implementing a new API in
libvirt. Remember that new API consists of any new public functions, as
well as the addition of flags or extensions of XML used by existing
functions.</p>
<p>Before you begin coding, it is critical that you propose your changes on
the libvirt mailing list and get feedback on your ideas to make sure
what you're proposing fits with the general direction of the project.
Even before doing a proof of concept implementation, send an email
giving an overview of the functionality you think should be added to
libvirt. Someone may already be working on the feature you want. Also,
recognize that everything you write is likely to undergo significant
rework as you discuss it with the other developers, so don't wait too
long before getting feedback.</p>
<p>Adding a new API to libvirt is not difficult, but there are quite a few
steps. This document assumes that you are familiar with C programming
and have checked out the libvirt code from the source code repository
and successfully built the existing tree. Instructions on how to check
out and build the code can be found at:</p>
<p><a class="reference external" href="https://libvirt.org/downloads.html">https://libvirt.org/downloads.html</a></p>
<p>Once you have a working development environment, the steps to create a
new API are:</p>
<ol class="arabic simple">
<li><p>define the public API</p></li>
<li><p>define the internal driver API</p></li>
<li><p>implement the public API</p></li>
<li><p>implement the remote protocol:</p>
<ol class="arabic simple">
<li><p>define the wire protocol format</p></li>
<li><p>implement the RPC client</p></li>
<li><p>implement the server side dispatcher</p></li>
</ol>
</li>
<li><p>use new API where appropriate in drivers</p></li>
<li><p>add virsh support</p></li>
<li><p>add common handling for new API</p></li>
<li><p>for each driver that can support the new API:</p>
<ol class="arabic simple">
<li><p>add prerequisite support</p></li>
<li><p>fully implement new API</p></li>
</ol>
</li>
</ol>
<p>It is, of course, possible to implement the pieces in any order, but if
the development tasks are completed in the order listed, the code will
compile after each step. Given the number of changes required,
verification after each step is highly recommended.</p>
<p>Submit new code in the form of one patch per step. That's not to say
submit patches before you have working functionality--get the whole
thing working and make sure you're happy with it. Then use git to break
the changes into pieces so you don't drop a big blob of code on the
mailing list in one go. Also, you should follow the upstream tree, and
rebase your series to adapt your patches to work with any other changes
that were accepted upstream during your development.</p>
<p>Don't mix anything else into the patches you submit. The patches should
be the minimal changes required to implement the functionality you're
adding. If you notice a bug in unrelated code (i.e., code you don't have
to touch to implement your API change) during development, create a
patch that just addresses that bug and submit it separately.</p>
<div class="section" id="defining-the-public-api">
<h1><a class="toc-backref" href="#id1">Defining the public API</a><a class="headerlink" href="#defining-the-public-api" title="Link to this headline">¶</a></h1>
<p>The first task is to define the public API. If the new API involves an
XML extension, you have to enhance the RelaxNG schema and document the
new elements or attributes:</p>
<p><span class="docutils literal">src/conf/schemas/domaincommon.rng         docs/formatdomain.rst</span></p>
<p>If the API extension involves a new function, you have to add a
declaration in the public header, and arrange to export the function
name (symbol) so other programs can link against the libvirt library and
call the new function:</p>
<p><span class="docutils literal"><span class="pre">include/libvirt/libvirt-$MODULE.h.in</span>         src/libvirt_public.syms</span></p>
<p>Please consult our <a class="reference external" href="coding-style.html#xml-element-and-attribute-naming">coding
style</a> guide on
elements and attribute names.</p>
<p>This task is in many ways the most important to get right, since once
the API has been committed to the repository, it's libvirt's policy
never to change it. Mistakes in the implementation are bugs that you can
fix. Make a mistake in the API definition and you're stuck with it, so
think carefully about the interface and don't be afraid to rework it as
you go through the process of implementing it.</p>
</div>
<div class="section" id="defining-the-internal-api">
<h1><a class="toc-backref" href="#id2">Defining the internal API</a><a class="headerlink" href="#defining-the-internal-api" title="Link to this headline">¶</a></h1>
<p>Each public API call is associated with a driver, such as a host
virtualization driver, a network virtualization driver, a storage
virtualization driver, a state driver, or a device monitor. Adding the
internal API is ordinarily a matter of adding a new member to the struct
representing one of these drivers.</p>
<p>Of course, it's possible that the new API will involve the creation of
an entirely new driver type, in which case the changes will include the
creation of a new struct type to represent the new driver type.</p>
<p>The driver structs are defined in:</p>
<p><span class="docutils literal"><span class="pre">src/driver-$MODULE.h</span></span></p>
<p>To define the internal API, first typedef the driver function prototype
and then add a new field for it to the relevant driver struct. Then,
update all existing instances of the driver to provide a <span class="docutils literal">NULL</span> stub
for the new function.</p>
</div>
<div class="section" id="implementing-the-public-api">
<h1><a class="toc-backref" href="#id3">Implementing the public API</a><a class="headerlink" href="#implementing-the-public-api" title="Link to this headline">¶</a></h1>
<p>Implementing the public API is largely a formality in which we wire up
public API to the internal driver API. The public API implementation
takes care of some basic validity checks before passing control to the
driver implementation. In RFC 2119 vocabulary, this function:</p>
<ol class="arabic simple">
<li><p>SHOULD log a message with VIR_DEBUG() indicating that it is being
called and its parameters;</p></li>
<li><p>MUST call virResetLastError();</p></li>
<li><p>SHOULD confirm that the connection is valid with
virCheckConnectReturn() or virCheckConnectGoto();</p></li>
<li><p><strong>SECURITY: If the API requires a connection with write privileges,
MUST confirm that the connection flags do not indicate that the
connection is read-only with virCheckReadOnlyGoto();</strong></p></li>
<li><p>SHOULD do basic validation of the parameters that are being passed
in, using helpers like virCheckNonNullArgGoto();</p></li>
<li><p>MUST confirm that the driver for this connection exists and that it
implements this function;</p></li>
<li><p>MUST call the internal API;</p></li>
<li><p>SHOULD log a message with VIR_DEBUG() indicating that it is
returning, its return value, and status.</p></li>
<li><p>MUST return status to the caller.</p></li>
</ol>
<p>The public API calls are implemented in:</p>
<p><span class="docutils literal"><span class="pre">src/libvirt-$MODULE.c</span></span></p>
</div>
<div class="section" id="implementing-the-remote-protocol">
<h1><a class="toc-backref" href="#id4">Implementing the remote protocol</a><a class="headerlink" href="#implementing-the-remote-protocol" title="Link to this headline">¶</a></h1>
<p>Implementing the remote protocol is essentially a straightforward
exercise which is probably most easily understood by referring to the
existing code.</p>
<div class="section" id="defining-the-wire-protocol-format">
<h2><a class="toc-backref" href="#id5">Defining the wire protocol format</a><a class="headerlink" href="#defining-the-wire-protocol-format" title="Link to this headline">¶</a></h2>
<p>Defining the wire protocol involves making additions to:</p>
<p><span class="docutils literal">src/remote/remote_protocol.x</span></p>
<p>First, create two new structs for each new function that you're adding
to the API. One struct describes the parameters to be passed to the
remote function, and a second struct describes the value returned by the
remote function. The one exception to this rule is that functions that
return only 0 or -1 for status do not require a struct for returned
data.</p>
<p>Second, add values to the remote_procedure enum for each new function
added to the API.</p>
<p>Once these changes are in place, it's necessary to run 'make rpcgen' in
the src directory to create the .c and .h files required by the remote
protocol code. This must be done on a Linux host using the GLibC rpcgen
program. Other rpcgen versions may generate code which results in bogus
compile time warnings. This regenerates the following files:</p>
<p><span class="docutils literal">src/remote/remote_daemon_dispatch_stubs.h         src/remote/remote_daemon_dispatch.h         src/remote/remote_daemon_dispatch.c         src/remote/remote_protocol.c         src/remote/remote_protocol.h</span></p>
</div>
<div class="section" id="implement-the-rpc-client">
<h2><a class="toc-backref" href="#id6">Implement the RPC client</a><a class="headerlink" href="#implement-the-rpc-client" title="Link to this headline">¶</a></h2>
<p>Implementing the RPC client uses the rpcgen generated .h files. The
remote method calls go in:</p>
<p><span class="docutils literal">src/remote/remote_driver.c</span></p>
<p>Each remote method invocation does the following:</p>
<ol class="arabic simple">
<li><p>locks the remote driver;</p></li>
<li><p>sets up the method arguments;</p></li>
<li><p>invokes the remote function;</p></li>
<li><p>checks the return value, if necessary;</p></li>
<li><p>extracts any returned data;</p></li>
<li><p>frees any returned data;</p></li>
<li><p>unlocks the remote driver.</p></li>
</ol>
</div>
<div class="section" id="implement-the-server-side-dispatcher">
<h2><a class="toc-backref" href="#id7">Implement the server side dispatcher</a><a class="headerlink" href="#implement-the-server-side-dispatcher" title="Link to this headline">¶</a></h2>
<p>Implementing the server side of the remote function call is simply a
matter of deserializing the parameters passed in from the remote caller
and passing them to the corresponding internal API function. The server
side dispatchers are implemented in:</p>
<p><span class="docutils literal">src/remote/remote_daemon_dispatch.c</span></p>
<p>Again, this step uses the .h files generated by make rpcgen.</p>
<p>After all three pieces of the remote protocol are complete, and the
generated files have been updated, it will be necessary to update the
file:</p>
<p><span class="docutils literal"><span class="pre">src/remote_protocol-structs</span></span></p>
<p>This file should only have new lines added; modifications to existing
lines probably imply a backwards-incompatible API change.</p>
</div>
</div>
<div class="section" id="use-the-new-api-internally">
<h1><a class="toc-backref" href="#id8">Use the new API internally</a><a class="headerlink" href="#use-the-new-api-internally" title="Link to this headline">¶</a></h1>
<p>Sometimes, a new API serves as a superset of existing API, by adding
more granularity in what can be managed. When this is the case, it makes
sense to share a common implementation by making the older API become a
trivial wrapper around the new API, rather than duplicating the common
code. This step should not introduce any semantic differences for the
old API, and is not necessary if the new API has no relation to existing
API.</p>
</div>
<div class="section" id="expose-the-new-api-in-virsh">
<h1><a class="toc-backref" href="#id9">Expose the new API in virsh</a><a class="headerlink" href="#expose-the-new-api-in-virsh" title="Link to this headline">¶</a></h1>
<p>All new API should be manageable from the virsh command line shell. This
proves that the API is sufficient for the intended purpose, and helps to
identify whether the proposed API needs slight changes for easier usage.
However, remember that virsh is used to connect to hosts running older
versions of libvirtd, so new commands should have fallbacks to an older
API if possible; implementing the virsh hooks at this point makes it
very easy to test these fallbacks. Also remember to document virsh
additions.</p>
<p>A virsh command is composed of a few pieces of code. You need to define
an array of vshCmdInfo structs for each new command that contain the
help text and the command description text. You also need an array of
vshCmdOptDef structs to describe the command options. Once you have
those pieces in place you can write the function implementing the virsh
command. Finally, you need to add the new command to the commands[]
array. The following files need changes:</p>
<p><span class="docutils literal"><span class="pre">tools/virsh-$MODULE.c</span>         tools/virsh.pod</span></p>
</div>
<div class="section" id="implement-the-driver-methods">
<h1><a class="toc-backref" href="#id10">Implement the driver methods</a><a class="headerlink" href="#implement-the-driver-methods" title="Link to this headline">¶</a></h1>
<p>So, after all that, we get to the fun part. All functionality in libvirt
is implemented inside a driver. Thus, here is where you implement
whatever functionality you're adding to libvirt. You'll either need to
add additional files to the src directory or extend files that are
already there, depending on what functionality you're adding.</p>
<div class="section" id="implement-common-handling">
<h2><a class="toc-backref" href="#id11">Implement common handling</a><a class="headerlink" href="#implement-common-handling" title="Link to this headline">¶</a></h2>
<p>If the new API is applicable to more than one driver, it may make sense
to provide some utility routines, or to factor some of the work into the
dispatcher, to avoid reimplementing the same code in every driver. In
the example code, this involved adding a member to the virDomainDef
struct for mapping between the XML API addition and the in-memory
representation of a domain, along with updating all clients to use the
new member. Up to this point, there have been no changes to existing
semantics, and the new APIs will fail unless they are used in the same
way as the older API wrappers.</p>
</div>
<div class="section" id="implement-driver-handling">
<h2><a class="toc-backref" href="#id12">Implement driver handling</a><a class="headerlink" href="#implement-driver-handling" title="Link to this headline">¶</a></h2>
<p>The remaining patches should only touch one driver at a time. It is
possible to implement all changes for a driver in one patch, but for
review purposes it may still make sense to break things into simpler
steps. Here is where the new APIs finally start working.</p>
<p>It is always a good idea to patch the test driver in addition to the
target driver, to prove that the API can be used for more than one
driver.</p>
<p>Any cleanups resulting from the changes should be added as separate
patches at the end of the series.</p>
<p>Once you have working functionality, run ninja test on each patch of the
series before submitting patches. It may also be worth writing tests for
the libvirt-TCK testsuite to exercise your new API, although those
patches are not kept in the libvirt repository.</p>
</div>
</div>
</div>
    </div>
    <div id="nav">
      <div id="home">
        <a href="index.html">Home</a>
      </div>
      <div id="jumplinks">
        <ul>
          <li>
            <a href="downloads.html">Download</a>
          </li>
          <li>
            <a href="contribute.html">Contribute</a>
          </li>
          <li>
            <a href="docs.html">Docs</a>
          </li>
        </ul>
      </div>
      <div id="search">
        <form id="simplesearch" action="https://www.google.com/search" enctype="application/x-www-form-urlencoded" method="get">
          <div>
            <input id="searchsite" name="sitesearch" type="hidden" value="libvirt.org"/>
            <input id="searchq" name="q" type="text" size="12" value=""/>
            <input name="submit" type="submit" value="Go"/>
          </div>
        </form>
        <div id="advancedsearch">
          <span>
            <input type="radio" name="what" id="whatwebsite" checked="checked" value="website"/>
            <label for="whatwebsite">Website</label>
          </span>
          <span>
            <input type="radio" name="what" id="whatwiki" value="wiki"/>
            <label for="whatwiki">Wiki</label>
          </span>
          <span>
            <input type="radio" name="what" id="whatdevs" value="devs"/>
            <label for="whatdevs">Developers list</label>
          </span>
          <span>
            <input type="radio" name="what" id="whatusers" value="users"/>
            <label for="whatusers">Users list</label>
          </span>
        </div>
      </div>
    </div>
    <div id="footer">
      <div id="contact">
        <h3>Contact</h3>
        <ul>
          <li>
            <a href="contact.html#mailing-lists">email</a>
          </li>
          <li>
            <a href="contact.html#irc">irc</a>
          </li>
        </ul>
      </div>
      <div id="community">
        <h3>Community</h3>
        <ul>
          <li>
            <a href="https://twitter.com/hashtag/libvirt">twitter</a>
          </li>
          <li>
            <a href="https://stackoverflow.com/questions/tagged/libvirt">stackoverflow</a>
          </li>
          <li>
            <a href="https://serverfault.com/questions/tagged/libvirt">serverfault</a>
          </li>
        </ul>
      </div>
      <div id="contribute">
        <h3>Contribute</h3>
        <ul>
          <li>
            <a href="https://gitlab.com/libvirt/libvirt/-/blob/master/docs/api_extension.rst">edit this page</a>
          </li>
        </ul>
      </div>
      <div id="conduct">
            Participants in the libvirt project agree to abide by <a href="governance.html#code-of-conduct">the project code of conduct</a></div>
      <br class="clear"/>
    </div>
  </body>
</html>
