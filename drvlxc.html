<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
  <!--
        This file is autogenerated from docs/drvlxc.rst
        Do not edit this file. Changes will be lost.
      -->
  <!--
        This page was generated at Wed Apr 19 07:14:27 2023 UTC.
      -->
  <head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <link rel="stylesheet" type="text/css" href="css/main.css"/>
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/>
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/>
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/>
    <link rel="manifest" href="/manifest.json"/>
    <meta name="theme-color" content="#ffffff"/>
    <title>libvirt: LXC container driver</title>
    <meta name="description" content="libvirt, virtualization, virtualization API"/>
    <script type="text/javascript" src="js/main.js">
      <!--// forces non-empty element-->
    </script>
  </head>
  <body onload="pageload()">
    <div id="body">
      <div class="document" id="lxc-container-driver">
<h1>LXC container driver</h1>

<div class="contents topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#control-groups-requirements" id="id1">Control groups Requirements</a></p></li>
<li><p><a class="reference internal" href="#namespace-requirements" id="id2">Namespace requirements</a></p></li>
<li><p><a class="reference internal" href="#default-container-setup" id="id3">Default container setup</a></p>
<ul>
<li><p><a class="reference internal" href="#command-line-arguments" id="id4">Command line arguments</a></p></li>
<li><p><a class="reference internal" href="#environment-variables" id="id5">Environment variables</a></p></li>
<li><p><a class="reference internal" href="#filesystem-mounts" id="id6">Filesystem mounts</a></p></li>
<li><p><a class="reference internal" href="#device-nodes" id="id7">Device nodes</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#security-considerations" id="id8">Security considerations</a></p>
<ul>
<li><p><a class="reference internal" href="#network-isolation" id="id9">Network isolation</a></p></li>
<li><p><a class="reference internal" href="#filesystem-isolation" id="id10">Filesystem isolation</a></p></li>
<li><p><a class="reference internal" href="#user-and-group-isolation" id="id11">User and group isolation</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#location-of-configuration-files" id="id12">Location of configuration files</a></p></li>
<li><p><a class="reference internal" href="#systemd-socket-activation-integration" id="id13">Systemd Socket Activation Integration</a></p></li>
<li><p><a class="reference internal" href="#container-security" id="id14">Container security</a></p>
<ul>
<li><p><a class="reference internal" href="#svirt-selinux" id="id15">sVirt SELinux</a></p></li>
<li><p><a class="reference internal" href="#auditing" id="id16">Auditing</a></p></li>
<li><p><a class="reference internal" href="#device-access" id="id17">Device access</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#example-configurations" id="id18">Example configurations</a></p>
<ul>
<li><p><a class="reference internal" href="#example-config-version-1" id="id19">Example config version 1</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#altering-the-available-capabilities" id="id20">Altering the available capabilities</a></p></li>
<li><p><a class="reference internal" href="#inherit-namespaces" id="id21">Inherit namespaces</a></p></li>
<li><p><a class="reference internal" href="#container-usage-management" id="id22">Container usage / management</a></p>
<ul>
<li><p><a class="reference internal" href="#defining-saving-container-configuration" id="id23">Defining (saving) container configuration</a></p></li>
<li><p><a class="reference internal" href="#viewing-container-configuration" id="id24">Viewing container configuration</a></p></li>
<li><p><a class="reference internal" href="#starting-containers" id="id25">Starting containers</a></p></li>
<li><p><a class="reference internal" href="#stopping-containers" id="id26">Stopping containers</a></p></li>
<li><p><a class="reference internal" href="#rebooting-a-container" id="id27">Rebooting a container</a></p></li>
<li><p><a class="reference internal" href="#undefining-deleting-a-container-configuration" id="id28">Undefining (deleting) a container configuration</a></p></li>
<li><p><a class="reference internal" href="#connecting-to-a-container-console" id="id29">Connecting to a container console</a></p></li>
<li><p><a class="reference internal" href="#running-commands-in-a-container" id="id30">Running commands in a container</a></p></li>
<li><p><a class="reference internal" href="#monitoring-container-utilization" id="id31">Monitoring container utilization</a></p></li>
<li><p><a class="reference internal" href="#converting-lxc-container-configuration" id="id32">Converting LXC container configuration</a></p></li>
</ul>
</li>
</ul>
</div>
<p>The libvirt LXC driver manages "Linux Containers". At their simplest, containers
can just be thought of as a collection of processes, separated from the main
host processes via a set of resource namespaces and constrained via control
groups resource tunables. The libvirt LXC driver has no dependency on the LXC
userspace tools hosted on sourceforge.net. It directly utilizes the relevant
kernel features to build the container environment. This allows for sharing of
many libvirt technologies across both the QEMU/KVM and LXC drivers. In
particular sVirt for mandatory access control, auditing of operations,
integration with control groups and many other features.</p>
<div class="section" id="control-groups-requirements">
<h1><a class="toc-backref" href="#id1">Control groups Requirements</a><a class="headerlink" href="#control-groups-requirements" title="Link to this headline">¶</a></h1>
<p>In order to control the resource usage of processes inside containers, the
libvirt LXC driver requires that certain cgroups controllers are mounted on the
host OS. The minimum required controllers are 'cpuacct', 'memory' and 'devices',
while recommended extra controllers are 'cpu', 'freezer' and 'blkio'. Libvirt
will not mount the cgroups filesystem itself, leaving this up to the init system
to take care of. Systemd will do the right thing in this respect, while for
other init systems the <span class="docutils literal">cgconfig</span> init service will be required. For further
information, consult the general libvirt <a class="reference external" href="cgroups.html">cgroups
documentation</a>.</p>
</div>
<div class="section" id="namespace-requirements">
<h1><a class="toc-backref" href="#id2">Namespace requirements</a><a class="headerlink" href="#namespace-requirements" title="Link to this headline">¶</a></h1>
<p>In order to separate processes inside a container from those in the primary
"host" OS environment, the libvirt LXC driver requires that certain kernel
namespaces are compiled in. Libvirt currently requires the 'mount', 'ipc',
'pid', and 'uts' namespaces to be available. If separate network interfaces are
desired, then the 'net' namespace is required. If the guest configuration
declares a <a class="reference external" href="formatdomain.html#container-boot">UID or GID mapping</a>, the
'user' namespace will be enabled to apply these. <strong>A suitably configured UID/GID
mapping is a pre-requisite to making containers secure, in the absence of sVirt
confinement.</strong></p>
</div>
<div class="section" id="default-container-setup">
<h1><a class="toc-backref" href="#id3">Default container setup</a><a class="headerlink" href="#default-container-setup" title="Link to this headline">¶</a></h1>
<div class="section" id="command-line-arguments">
<h2><a class="toc-backref" href="#id4">Command line arguments</a><a class="headerlink" href="#command-line-arguments" title="Link to this headline">¶</a></h2>
<p>When the container "init" process is started, it will typically not be given any
command line arguments (eg the equivalent of the bootloader args visible in
<span class="docutils literal">/proc/cmdline</span>). If any arguments are desired, then must be explicitly set in
the container XML configuration via one or more <span class="docutils literal">initarg</span> elements. For
example, to run <span class="docutils literal">systemd <span class="pre">--unit</span> emergency.service</span> would use the following XML</p>
<pre class="literal-block">&lt;os&gt;
  &lt;type arch='x86_64'&gt;exe&lt;/type&gt;
  &lt;init&gt;/bin/systemd&lt;/init&gt;
  &lt;initarg&gt;--unit&lt;/initarg&gt;
  &lt;initarg&gt;emergency.service&lt;/initarg&gt;
&lt;/os&gt;</pre>
</div>
<div class="section" id="environment-variables">
<h2><a class="toc-backref" href="#id5">Environment variables</a><a class="headerlink" href="#environment-variables" title="Link to this headline">¶</a></h2>
<p>When the container "init" process is started, it will be given several useful
environment variables. The following standard environment variables are mandated
by <a class="reference external" href="https://www.freedesktop.org/wiki/Software/systemd/ContainerInterface">systemd container
interface</a>
to be provided by all container technologies on Linux.</p>
<dl class="simple">
<dt><span class="docutils literal">container</span></dt>
<dd><p>The fixed string <span class="docutils literal"><span class="pre">libvirt-lxc</span></span> to identify libvirt as the creator</p>
</dd>
<dt><span class="docutils literal">container_uuid</span></dt>
<dd><p>The UUID assigned to the container by libvirt</p>
</dd>
<dt><span class="docutils literal">PATH</span></dt>
<dd><p>The fixed string <span class="docutils literal"><span class="pre">/bin:/usr/bin</span></span></p>
</dd>
<dt><span class="docutils literal">TERM</span></dt>
<dd><p>The fixed string <span class="docutils literal">linux</span></p>
</dd>
<dt><span class="docutils literal">HOME</span></dt>
<dd><p>The fixed string <span class="docutils literal">/</span></p>
</dd>
</dl>
<p>In addition to the standard variables, the following libvirt specific
environment variables are also provided</p>
<dl class="simple">
<dt><span class="docutils literal">LIBVIRT_LXC_NAME</span></dt>
<dd><p>The name assigned to the container by libvirt</p>
</dd>
<dt><span class="docutils literal">LIBVIRT_LXC_UUID</span></dt>
<dd><p>The UUID assigned to the container by libvirt</p>
</dd>
<dt><span class="docutils literal">LIBVIRT_LXC_CMDLINE</span></dt>
<dd><p>The unparsed command line arguments specified in the container configuration.
Use of this is discouraged, in favour of passing arguments directly to the
container init process via the <span class="docutils literal">initarg</span> config element.</p>
</dd>
</dl>
</div>
<div class="section" id="filesystem-mounts">
<h2><a class="toc-backref" href="#id6">Filesystem mounts</a><a class="headerlink" href="#filesystem-mounts" title="Link to this headline">¶</a></h2>
<p>In the absence of any explicit configuration, the container will inherit the
host OS filesystem mounts. A number of mount points will be made read only, or
re-mounted with new instances to provide container specific data. The following
special mounts are setup by libvirt</p>
<ul class="simple">
<li><p><span class="docutils literal">/dev</span> a new "tmpfs" pre-populated with authorized device nodes</p></li>
<li><p><span class="docutils literal">/dev/pts</span> a new private "devpts" instance for console devices</p></li>
<li><p><span class="docutils literal">/sys</span> the host "sysfs" instance remounted read-only</p></li>
<li><p><span class="docutils literal">/proc</span> a new instance of the "proc" filesystem</p></li>
<li><p><span class="docutils literal">/proc/sys</span> the host "/proc/sys" bind-mounted read-only</p></li>
<li><p><span class="docutils literal">/sys/fs/selinux</span> the host "selinux" instance remounted read-only</p></li>
<li><p><span class="docutils literal">/sys/fs/cgroup/NNNN</span> the host cgroups controllers bind-mounted to only
expose the sub-tree associated with the container</p></li>
<li><p><span class="docutils literal">/proc/meminfo</span> a FUSE backed file reflecting memory limits of the
container</p></li>
</ul>
</div>
<div class="section" id="device-nodes">
<h2><a class="toc-backref" href="#id7">Device nodes</a><a class="headerlink" href="#device-nodes" title="Link to this headline">¶</a></h2>
<p>The container init process will be started with <span class="docutils literal">CAP_MKNOD</span> capability removed
and blocked from re-acquiring it. As such it will not be able to create any
device nodes in <span class="docutils literal">/dev</span> or anywhere else in its filesystems. Libvirt itself
will take care of pre-populating the <span class="docutils literal">/dev</span> filesystem with any devices that
the container is authorized to use. The current devices that will be made
available to all containers are</p>
<ul class="simple">
<li><p><span class="docutils literal">/dev/zero</span></p></li>
<li><p><span class="docutils literal">/dev/null</span></p></li>
<li><p><span class="docutils literal">/dev/full</span></p></li>
<li><p><span class="docutils literal">/dev/random</span></p></li>
<li><p><span class="docutils literal">/dev/urandom</span></p></li>
<li><p><span class="docutils literal">/dev/stdin</span> symlinked to <span class="docutils literal">/proc/self/fd/0</span></p></li>
<li><p><span class="docutils literal">/dev/stdout</span> symlinked to <span class="docutils literal">/proc/self/fd/1</span></p></li>
<li><p><span class="docutils literal">/dev/stderr</span> symlinked to <span class="docutils literal">/proc/self/fd/2</span></p></li>
<li><p><span class="docutils literal">/dev/fd</span> symlinked to <span class="docutils literal">/proc/self/fd</span></p></li>
<li><p><span class="docutils literal">/dev/ptmx</span> symlinked to <span class="docutils literal">/dev/pts/ptmx</span></p></li>
<li><p><span class="docutils literal">/dev/console</span> symlinked to <span class="docutils literal">/dev/pts/0</span></p></li>
</ul>
<p>In addition, for every console defined in the guest configuration, a symlink
will be created from <span class="docutils literal">/dev/ttyN</span> symlinked to the corresponding <span class="docutils literal">/dev/pts/M</span>
pseudo TTY device. The first console will be <span class="docutils literal">/dev/tty1</span>, with further
consoles numbered incrementally from there.</p>
<p>Since /dev/ttyN and /dev/console are linked to the pts devices. The tty device
of login program is pts device. The pam module securetty may prevent root user
from logging in container. If you want root user to log in container
successfully, add the pts device to the file /etc/securetty of container.</p>
<p>Further block or character devices will be made available to containers
depending on their configuration.</p>
</div>
</div>
<div class="section" id="security-considerations">
<h1><a class="toc-backref" href="#id8">Security considerations</a><a class="headerlink" href="#security-considerations" title="Link to this headline">¶</a></h1>
<p>The libvirt LXC driver is fairly flexible in how it can be configured, and as
such does not enforce a requirement for strict security separation between a
container and the host. This allows it to be used in scenarios where only
resource control capabilities are important, and resource sharing is desired.
Applications wishing to ensure secure isolation between a container and the host
must ensure that they are writing a suitable configuration.</p>
<div class="section" id="network-isolation">
<h2><a class="toc-backref" href="#id9">Network isolation</a><a class="headerlink" href="#network-isolation" title="Link to this headline">¶</a></h2>
<p>If the guest configuration does not list any network interfaces, the <span class="docutils literal">network</span>
namespace will not be activated, and thus the container will see all the host's
network interfaces. This will allow apps in the container to bind to/connect
from TCP/UDP addresses and ports from the host OS. It also allows applications
to access UNIX domain sockets associated with the host OS, which are in the
abstract namespace. If access to UNIX domains sockets in the abstract namespace
is not wanted, then applications should set the <span class="docutils literal">&lt;privnet/&gt;</span> flag in the
<span class="docutils literal"><span class="pre">&lt;features&gt;....&lt;/features&gt;</span></span> element.</p>
</div>
<div class="section" id="filesystem-isolation">
<h2><a class="toc-backref" href="#id10">Filesystem isolation</a><a class="headerlink" href="#filesystem-isolation" title="Link to this headline">¶</a></h2>
<p>If the guest configuration does not list any filesystems, then the container
will be set up with a root filesystem that matches the host's root filesystem.
As noted earlier, only a few locations such as <span class="docutils literal">/dev</span>, <span class="docutils literal">/proc</span> and <span class="docutils literal">/sys</span>
will be altered. This means that, in the absence of restrictions from sVirt, a
process running as user/group N:M inside the container will be able to access
almost exactly the same files as a process running as user/group N:M in the
host.</p>
<p>There are multiple options for restricting this. It is possible to simply map
the existing root filesystem through to the container in read-only mode.
Alternatively a completely separate root filesystem can be configured for the
guest. In both cases, further sub-mounts can be applied to customize the content
that is made visible. Note that in the absence of sVirt controls, it is still
possible for the root user in a container to unmount any sub-mounts applied. The
user namespace feature can also be used to restrict access to files based on the
UID/GID mappings.</p>
<p>Sharing the host filesystem tree, also allows applications to access UNIX
domains sockets associated with the host OS, which are in the filesystem
namespaces. It should be noted that a number of init systems including at least
<span class="docutils literal">systemd</span> and <span class="docutils literal">upstart</span> have UNIX domain socket which are used to control
their operation. Thus, if the directory/filesystem holding their UNIX domain
socket is exposed to the container, it will be possible for a user in the
container to invoke operations on the init service in the same way it could if
outside the container. This also applies to other applications in the host which
use UNIX domain sockets in the filesystem, such as DBus, Libvirtd, and many
more. If this is not desired, then applications should either specify the
UID/GID mapping in the configuration to enable user namespaces and thus block
access to the UNIX domain socket based on permissions, or should ensure the
relevant directories have a bind mount to hide them. This is particularly
important for the <span class="docutils literal">/run</span> or <span class="docutils literal">/var/run</span> directories.</p>
</div>
<div class="section" id="user-and-group-isolation">
<h2><a class="toc-backref" href="#id11">User and group isolation</a><a class="headerlink" href="#user-and-group-isolation" title="Link to this headline">¶</a></h2>
<p>If the guest configuration does not list any ID mapping, then the user and group
IDs used inside the container will match those used outside the container. In
addition, the capabilities associated with a process in the container will infer
the same privileges they would for a process in the host. This has obvious
implications for security, since a root user inside the container will be able
to access any file owned by root that is visible to the container, and perform
more or less any privileged kernel operation. In the absence of additional
protection from sVirt, this means that the root user inside a container is
effectively as powerful as the root user in the host. There is no security
isolation of the root user.</p>
<p>The ID mapping facility was introduced to allow for stricter control over the
privileges of users inside the container. It allows apps to define rules such as
"user ID 0 in the container maps to user ID 1000 in the host". In addition the
privileges associated with capabilities are somewhat reduced so that they cannot
be used to escape from the container environment. A full description of user
namespaces is outside the scope of this document, however LWN has <a class="reference external" href="https://lwn.net/Articles/532593/">a good
write-up on the topic</a>. From the libvirt
point of view, the key thing to remember is that defining an ID mapping for
users and groups in the container XML configuration causes libvirt to activate
the user namespace feature.</p>
</div>
</div>
<div class="section" id="location-of-configuration-files">
<h1><a class="toc-backref" href="#id12">Location of configuration files</a><a class="headerlink" href="#location-of-configuration-files" title="Link to this headline">¶</a></h1>
<p>The LXC driver comes with sane default values. However, during its
initialization it reads a configuration file which offers system administrator
to override some of that default. The file is located under
<span class="docutils literal">/etc/libvirt/lxc.conf</span></p>
</div>
<div class="section" id="systemd-socket-activation-integration">
<h1><a class="toc-backref" href="#id13">Systemd Socket Activation Integration</a><a class="headerlink" href="#systemd-socket-activation-integration" title="Link to this headline">¶</a></h1>
<p>The libvirt LXC driver provides the ability to pass across pre-opened file
descriptors when starting LXC guests. This allows for libvirt LXC to support
systemd's <a class="reference external" href="https://0pointer.de/blog/projects/socket-activated-containers.html">socket activation
capability</a>,
where an incoming client connection in the host OS will trigger the startup of a
container, which runs another copy of systemd which gets passed the server
socket, and then activates the actual service handler in the container.</p>
<p>Let us assume that you already have a LXC guest created, running a systemd
instance as PID 1 inside the container, which has an SSHD service configured.
The goal is to automatically activate the container when the first SSH
connection is made. The first step is to create a couple of unit files for the
host OS systemd instance. The <span class="docutils literal">/etc/systemd/system/mycontainer.service</span> unit
file specifies how systemd will start the libvirt LXC container</p>
<pre class="literal-block">[Unit]
Description=My little container

[Service]
ExecStart=/usr/bin/virsh -c lxc:///system start --pass-fds 3 mycontainer
ExecStop=/usr/bin/virsh -c lxc:///system destroy mycontainer
Type=oneshot
RemainAfterExit=yes
KillMode=none</pre>
<p>The <span class="docutils literal"><span class="pre">--pass-fds</span> 3</span> argument specifies that the file descriptor number 3 that
<span class="docutils literal">virsh</span> inherits from systemd, is to be passed into the container. Since
<span class="docutils literal">virsh</span> will exit immediately after starting the container, the
<span class="docutils literal">RemainAfterExit</span> and <span class="docutils literal">KillMode</span> settings must be altered from their
defaults.</p>
<p>Next, the <span class="docutils literal">/etc/systemd/system/mycontainer.socket</span> unit file is created to get
the host systemd to listen on port 23 for TCP connections. When this unit file
is activated by the first incoming connection, it will cause the
<span class="docutils literal">mycontainer.service</span> unit to be activated with the FD corresponding to the
listening TCP socket passed in as FD 3.</p>
<pre class="literal-block">[Unit]
Description=The SSH socket of my little container

[Socket]
ListenStream=23</pre>
<p>Port 23 was picked here so that the container doesn't conflict with the host's
SSH which is on the normal port 22. That's it in terms of host side
configuration.</p>
<p>Inside the container, the <span class="docutils literal">/etc/systemd/system/sshd.socket</span> unit file must be
created</p>
<pre class="literal-block">[Unit]
Description=SSH Socket for Per-Connection Servers

[Socket]
ListenStream=23
Accept=yes</pre>
<p>The <span class="docutils literal">ListenStream</span> value listed in this unit file, must match the value used
in the host file. When systemd in the container receives the pre-opened FD from
libvirt during container startup, it looks at the <span class="docutils literal">ListenStream</span> values to
figure out which FD to give to which service. The actual service to start is
defined by a correspondingly named <span class="docutils literal"><span class="pre">/etc/systemd/system/sshd@.service</span></span></p>
<pre class="literal-block">[Unit]
Description=SSH Per-Connection Server for %I

[Service]
ExecStart=-/usr/sbin/sshd -i
StandardInput=socket</pre>
<p>Finally, make sure this SSH service is set to start on boot of the container, by
running the following command inside the container:</p>
<pre class="literal-block"># mkdir -p /etc/systemd/system/sockets.target.wants/
# ln -s /etc/systemd/system/sshd.socket /etc/systemd/system/sockets.target.wants/</pre>
<p>This example shows how to activate the container based on an incoming SSH
connection. If the container was also configured to have an httpd service, it
may be desirable to activate it upon either an httpd or a sshd connection
attempt. In this case, the <span class="docutils literal">mycontainer.socket</span> file in the host would simply
list multiple socket ports. Inside the container a separate <span class="docutils literal">xxxxx.socket</span>
file would need to be created for each service, with a corresponding
<span class="docutils literal">ListenStream</span> value set.</p>
</div>
<div class="section" id="container-security">
<h1><a class="toc-backref" href="#id14">Container security</a><a class="headerlink" href="#container-security" title="Link to this headline">¶</a></h1>
<div class="section" id="svirt-selinux">
<h2><a class="toc-backref" href="#id15">sVirt SELinux</a><a class="headerlink" href="#svirt-selinux" title="Link to this headline">¶</a></h2>
<p>In the absence of the "user" namespace being used, containers cannot be
considered secure against exploits of the host OS. The sVirt SELinux driver
provides a way to secure containers even when the "user" namespace is not used.
The cost is that writing a policy to allow execution of arbitrary OS is not
practical. The SELinux sVirt policy is typically tailored to work with a simpler
application confinement use case, as provided by the "libvirt-sandbox" project.</p>
</div>
<div class="section" id="auditing">
<h2><a class="toc-backref" href="#id16">Auditing</a><a class="headerlink" href="#auditing" title="Link to this headline">¶</a></h2>
<p>The LXC driver is integrated with libvirt's auditing subsystem, which causes
audit messages to be logged whenever there is an operation performed against a
container which has impact on host resources. So for example, start/stop, device
hotplug will all log audit messages providing details about what action occurred
and any resources associated with it. There are the following 3 types of audit
messages</p>
<ul class="simple">
<li><p><span class="docutils literal">VIRT_MACHINE_ID</span> - details of the SELinux process and image security
labels assigned to the container.</p></li>
<li><p><span class="docutils literal">VIRT_CONTROL</span> - details of an action / operation performed against a
container. There are the following types of operation</p>
<ul>
<li><p><span class="docutils literal">op=start</span> - a container has been started. Provides the machine name,
uuid and PID of the <span class="docutils literal">libvirt_lxc</span> controller process</p></li>
<li><p><span class="docutils literal">op=init</span> - the init PID of the container has been started. Provides the
machine name, uuid and PID of the <span class="docutils literal">libvirt_lxc</span> controller process and
PID of the init process (in the host PID namespace)</p></li>
<li><p><span class="docutils literal">op=stop</span> - a container has been stopped. Provides the machine name,
uuid</p></li>
</ul>
</li>
<li><p><span class="docutils literal">VIRT_RESOURCE</span> - details of a host resource associated with a container
action.</p></li>
</ul>
</div>
<div class="section" id="device-access">
<h2><a class="toc-backref" href="#id17">Device access</a><a class="headerlink" href="#device-access" title="Link to this headline">¶</a></h2>
<p>All containers are launched with the CAP_MKNOD capability cleared and removed
from the bounding set. Libvirt will ensure that the /dev filesystem is
pre-populated with all devices that a container is allowed to use. In addition,
the cgroup "device" controller is configured to block read/write/mknod from all
devices except those that a container is authorized to use.</p>
</div>
</div>
<div class="section" id="example-configurations">
<h1><a class="toc-backref" href="#id18">Example configurations</a><a class="headerlink" href="#example-configurations" title="Link to this headline">¶</a></h1>
<div class="section" id="example-config-version-1">
<h2><a class="toc-backref" href="#id19">Example config version 1</a><a class="headerlink" href="#example-config-version-1" title="Link to this headline">¶</a></h2>
<pre class="literal-block">&lt;domain type='lxc'&gt;
  &lt;name&gt;vm1&lt;/name&gt;
  &lt;memory&gt;500000&lt;/memory&gt;
  &lt;os&gt;
    &lt;type&gt;exe&lt;/type&gt;
    &lt;init&gt;/bin/sh&lt;/init&gt;
  &lt;/os&gt;
  &lt;vcpu&gt;1&lt;/vcpu&gt;
  &lt;clock offset='utc'/&gt;
  &lt;on_poweroff&gt;destroy&lt;/on_poweroff&gt;
  &lt;on_reboot&gt;restart&lt;/on_reboot&gt;
  &lt;on_crash&gt;destroy&lt;/on_crash&gt;
  &lt;devices&gt;
    &lt;emulator&gt;/usr/libexec/libvirt_lxc&lt;/emulator&gt;
    &lt;interface type='network'&gt;
      &lt;source network='default'/&gt;
    &lt;/interface&gt;
    &lt;console type='pty' /&gt;
  &lt;/devices&gt;
&lt;/domain&gt;</pre>
<p>In the &lt;emulator&gt; element, be sure you specify the correct path to libvirt_lxc,
if it does not live in /usr/libexec on your system.</p>
<p>The next example assumes there is a private root filesystem (perhaps
hand-crafted using busybox, or installed from media, debootstrap, whatever)
under /opt/vm-1-root:</p>
<pre class="literal-block">&lt;domain type='lxc'&gt;
  &lt;name&gt;vm1&lt;/name&gt;
  &lt;memory&gt;32768&lt;/memory&gt;
  &lt;os&gt;
    &lt;type&gt;exe&lt;/type&gt;
    &lt;init&gt;/init&lt;/init&gt;
  &lt;/os&gt;
  &lt;vcpu&gt;1&lt;/vcpu&gt;
  &lt;clock offset='utc'/&gt;
  &lt;on_poweroff&gt;destroy&lt;/on_poweroff&gt;
  &lt;on_reboot&gt;restart&lt;/on_reboot&gt;
  &lt;on_crash&gt;destroy&lt;/on_crash&gt;
  &lt;devices&gt;
    &lt;emulator&gt;/usr/libexec/libvirt_lxc&lt;/emulator&gt;
    &lt;filesystem type='mount'&gt;
      &lt;source dir='/opt/vm-1-root'/&gt;
      &lt;target dir='/'/&gt;
    &lt;/filesystem&gt;
    &lt;interface type='network'&gt;
      &lt;source network='default'/&gt;
    &lt;/interface&gt;
    &lt;console type='pty' /&gt;
  &lt;/devices&gt;
&lt;/domain&gt;</pre>
</div>
</div>
<div class="section" id="altering-the-available-capabilities">
<h1><a class="toc-backref" href="#id20">Altering the available capabilities</a><a class="headerlink" href="#altering-the-available-capabilities" title="Link to this headline">¶</a></h1>
<p>By default the libvirt LXC driver drops some capabilities among which CAP_MKNOD.
However <span class="since">since 1.2.6</span> libvirt can be told to keep or drop some
capabilities using a domain configuration like the following:</p>
<pre class="literal-block">...
&lt;features&gt;
  &lt;capabilities policy='default'&gt;
    &lt;mknod state='on'/&gt;
    &lt;sys_chroot state='off'/&gt;
  &lt;/capabilities&gt;
&lt;/features&gt;
...</pre>
<p>The capabilities children elements are named after the capabilities as defined
in <span class="docutils literal">man 7 capabilities</span>. An <span class="docutils literal">off</span> state tells libvirt to drop the
capability, while an <span class="docutils literal">on</span> state will force to keep the capability even though
this one is dropped by default.</p>
<p>The <span class="docutils literal">policy</span> attribute can be one of <span class="docutils literal">default</span>, <span class="docutils literal">allow</span> or <span class="docutils literal">deny</span>. It
defines the default rules for capabilities: either keep the default behavior
that is dropping a few selected capabilities, or keep all capabilities or drop
all capabilities. The interest of <span class="docutils literal">allow</span> and <span class="docutils literal">deny</span> is that they guarantee
that all capabilities will be kept (or removed) even if new ones are added
later.</p>
<p>The following example, drops all capabilities but CAP_MKNOD:</p>
<pre class="literal-block">...
&lt;features&gt;
  &lt;capabilities policy='deny'&gt;
    &lt;mknod state='on'/&gt;
  &lt;/capabilities&gt;
&lt;/features&gt;
...</pre>
<p>Note that allowing capabilities that are normally dropped by default can
seriously affect the security of the container and the host.</p>
</div>
<div class="section" id="inherit-namespaces">
<h1><a class="toc-backref" href="#id21">Inherit namespaces</a><a class="headerlink" href="#inherit-namespaces" title="Link to this headline">¶</a></h1>
<p>Libvirt allows you to inherit the namespace from container/process just like lxc
tools or docker provides to share the network namespace. The following can be
used to share required namespaces. If we want to share only one then the other
namespaces can be ignored. The netns option is specific to sharenet. It can be
used in cases we want to use existing network namespace rather than creating new
network namespace for the container. In this case privnet option will be
ignored.</p>
<pre class="literal-block">&lt;domain type='lxc' xmlns:lxc='http://libvirt.org/schemas/domain/lxc/1.0'&gt;
...
&lt;lxc:namespace&gt;
  &lt;lxc:sharenet type='netns' value='red'/&gt;
  &lt;lxc:shareuts type='name' value='container1'/&gt;
  &lt;lxc:shareipc type='pid' value='12345'/&gt;
&lt;/lxc:namespace&gt;
&lt;/domain&gt;</pre>
<p>The use of namespace passthrough requires libvirt &gt;= 1.2.19</p>
</div>
<div class="section" id="container-usage-management">
<h1><a class="toc-backref" href="#id22">Container usage / management</a><a class="headerlink" href="#container-usage-management" title="Link to this headline">¶</a></h1>
<p>As with any libvirt virtualization driver, LXC containers can be managed via a
wide variety of libvirt based tools. At the lowest level the <span class="docutils literal">virsh</span> command
can be used to perform many tasks, by passing the <span class="docutils literal"><span class="pre">-c</span> <span class="pre">lxc:///system</span></span> argument.
As an alternative to repeating the URI with every command, the
<span class="docutils literal">LIBVIRT_DEFAULT_URI</span> environment variable can be set to <span class="docutils literal"><span class="pre">lxc:///system</span></span>.
The examples that follow outline some common operations with virsh and LXC. For
further details about usage of virsh consult its manual page.</p>
<div class="section" id="defining-saving-container-configuration">
<h2><a class="toc-backref" href="#id23">Defining (saving) container configuration</a><a class="headerlink" href="#defining-saving-container-configuration" title="Link to this headline">¶</a></h2>
<p>The <span class="docutils literal">virsh define</span> command takes an XML configuration document and loads it
into libvirt, saving the configuration on disk</p>
<pre class="literal-block"># virsh -c lxc:///system define myguest.xml</pre>
</div>
<div class="section" id="viewing-container-configuration">
<h2><a class="toc-backref" href="#id24">Viewing container configuration</a><a class="headerlink" href="#viewing-container-configuration" title="Link to this headline">¶</a></h2>
<p>The <span class="docutils literal">virsh dumpxml</span> command can be used to view the current XML configuration
of a container. By default the XML output reflects the current state of the
container. If the container is running, it is possible to explicitly request the
persistent configuration, instead of the current live configuration using the
<span class="docutils literal"><span class="pre">--inactive</span></span> flag</p>
<pre class="literal-block"># virsh -c lxc:///system dumpxml myguest</pre>
</div>
<div class="section" id="starting-containers">
<h2><a class="toc-backref" href="#id25">Starting containers</a><a class="headerlink" href="#starting-containers" title="Link to this headline">¶</a></h2>
<p>The <span class="docutils literal">virsh start</span> command can be used to start a container from a previously
defined persistent configuration</p>
<pre class="literal-block"># virsh -c lxc:///system start myguest</pre>
<p>It is also possible to start so called "transient" containers, which do not
require a persistent configuration to be saved by libvirt, using the
<span class="docutils literal">virsh create</span> command.</p>
<pre class="literal-block"># virsh -c lxc:///system create myguest.xml</pre>
</div>
<div class="section" id="stopping-containers">
<h2><a class="toc-backref" href="#id26">Stopping containers</a><a class="headerlink" href="#stopping-containers" title="Link to this headline">¶</a></h2>
<p>The <span class="docutils literal">virsh shutdown</span> command can be used to request a graceful shutdown of the
container. By default this command will first attempt to send a message to the
init process via the <span class="docutils literal">/dev/initctl</span> device node. If no such device node
exists, then it will send SIGTERM to PID 1 inside the container.</p>
<pre class="literal-block"># virsh -c lxc:///system shutdown myguest</pre>
<p>If the container does not respond to the graceful shutdown request, it can be
forcibly stopped using the <span class="docutils literal">virsh destroy</span></p>
<pre class="literal-block"># virsh -c lxc:///system destroy myguest</pre>
</div>
<div class="section" id="rebooting-a-container">
<h2><a class="toc-backref" href="#id27">Rebooting a container</a><a class="headerlink" href="#rebooting-a-container" title="Link to this headline">¶</a></h2>
<p>The <span class="docutils literal">virsh reboot</span> command can be used to request a graceful shutdown of the
container. By default this command will first attempt to send a message to the
init process via the <span class="docutils literal">/dev/initctl</span> device node. If no such device node
exists, then it will send SIGHUP to PID 1 inside the container.</p>
<pre class="literal-block"># virsh -c lxc:///system reboot myguest</pre>
</div>
<div class="section" id="undefining-deleting-a-container-configuration">
<h2><a class="toc-backref" href="#id28">Undefining (deleting) a container configuration</a><a class="headerlink" href="#undefining-deleting-a-container-configuration" title="Link to this headline">¶</a></h2>
<p>The <span class="docutils literal">virsh undefine</span> command can be used to delete the persistent
configuration of a container. If the guest is currently running, this will turn
it into a "transient" guest.</p>
<pre class="literal-block"># virsh -c lxc:///system undefine myguest</pre>
</div>
<div class="section" id="connecting-to-a-container-console">
<h2><a class="toc-backref" href="#id29">Connecting to a container console</a><a class="headerlink" href="#connecting-to-a-container-console" title="Link to this headline">¶</a></h2>
<p>The <span class="docutils literal">virsh console</span> command can be used to connect to the text console
associated with a container.</p>
<pre class="literal-block"># virsh -c lxc:///system console myguest</pre>
<p>If the container has been configured with multiple console devices, then the
<span class="docutils literal"><span class="pre">--devname</span></span> argument can be used to choose the console to connect to. In LXC,
multiple consoles will be named as 'console0', 'console1', 'console2', etc.</p>
<pre class="literal-block"># virsh -c lxc:///system console myguest --devname console1</pre>
</div>
<div class="section" id="running-commands-in-a-container">
<h2><a class="toc-backref" href="#id30">Running commands in a container</a><a class="headerlink" href="#running-commands-in-a-container" title="Link to this headline">¶</a></h2>
<p>The <span class="docutils literal">virsh <span class="pre">lxc-enter-namespace</span></span> command can be used to enter the namespaces
and security context of a container and then execute an arbitrary command.</p>
<pre class="literal-block"># virsh -c lxc:///system lxc-enter-namespace myguest -- /bin/ls -al /dev</pre>
</div>
<div class="section" id="monitoring-container-utilization">
<h2><a class="toc-backref" href="#id31">Monitoring container utilization</a><a class="headerlink" href="#monitoring-container-utilization" title="Link to this headline">¶</a></h2>
<p>The <span class="docutils literal"><span class="pre">virt-top</span></span> command can be used to monitor the activity and resource
utilization of all containers on a host</p>
<pre class="literal-block"># virt-top -c lxc:///system</pre>
</div>
<div class="section" id="converting-lxc-container-configuration">
<h2><a class="toc-backref" href="#id32">Converting LXC container configuration</a><a class="headerlink" href="#converting-lxc-container-configuration" title="Link to this headline">¶</a></h2>
<p>The <span class="docutils literal">virsh <span class="pre">domxml-from-native</span></span> command can be used to convert most of the LXC
container configuration into a domain XML fragment</p>
<pre class="literal-block"># virsh -c lxc:///system domxml-from-native lxc-tools /var/lib/lxc/myguest/config</pre>
<p>This conversion has some limitations due to the fact that the domxml-from-native
command output has to be independent of the host. Here are a few things to take
care of before converting:</p>
<ul class="simple">
<li><p>Replace the fstab file referenced by lxc.mount by the corresponding
lxc.mount.entry lines.</p></li>
<li><p>Replace all relative sizes of tmpfs mount entries to absolute sizes. Also
make sure that tmpfs entries all have a size option (default is 50%).</p></li>
<li><p>Define lxc.cgroup.memory.limit_in_bytes to properly limit the memory
available to the container. The conversion will use 64MiB as the default.</p></li>
</ul>
</div>
</div>
</div>
    </div>
    <div id="nav">
      <div id="home">
        <a href="index.html">Home</a>
      </div>
      <div id="jumplinks">
        <ul>
          <li>
            <a href="downloads.html">Download</a>
          </li>
          <li>
            <a href="contribute.html">Contribute</a>
          </li>
          <li>
            <a href="docs.html">Docs</a>
          </li>
        </ul>
      </div>
      <div id="search">
        <form id="simplesearch" action="https://www.google.com/search" enctype="application/x-www-form-urlencoded" method="get">
          <div>
            <input id="searchsite" name="sitesearch" type="hidden" value="libvirt.org"/>
            <input id="searchq" name="q" type="text" size="12" value=""/>
            <input name="submit" type="submit" value="Go"/>
          </div>
        </form>
        <div id="advancedsearch">
          <span>
            <input type="radio" name="what" id="whatwebsite" checked="checked" value="website"/>
            <label for="whatwebsite">Website</label>
          </span>
          <span>
            <input type="radio" name="what" id="whatwiki" value="wiki"/>
            <label for="whatwiki">Wiki</label>
          </span>
          <span>
            <input type="radio" name="what" id="whatdevs" value="devs"/>
            <label for="whatdevs">Developers list</label>
          </span>
          <span>
            <input type="radio" name="what" id="whatusers" value="users"/>
            <label for="whatusers">Users list</label>
          </span>
        </div>
      </div>
    </div>
    <div id="footer">
      <div id="contact">
        <h3>Contact</h3>
        <ul>
          <li>
            <a href="contact.html#mailing-lists">email</a>
          </li>
          <li>
            <a href="contact.html#irc">irc</a>
          </li>
        </ul>
      </div>
      <div id="community">
        <h3>Community</h3>
        <ul>
          <li>
            <a href="https://twitter.com/hashtag/libvirt">twitter</a>
          </li>
          <li>
            <a href="https://stackoverflow.com/questions/tagged/libvirt">stackoverflow</a>
          </li>
          <li>
            <a href="https://serverfault.com/questions/tagged/libvirt">serverfault</a>
          </li>
        </ul>
      </div>
      <div id="contribute">
        <h3>Contribute</h3>
        <ul>
          <li>
            <a href="https://gitlab.com/libvirt/libvirt/-/blob/master/docs/drvlxc.rst">edit this page</a>
          </li>
        </ul>
      </div>
      <div id="conduct">
            Participants in the libvirt project agree to abide by <a href="governance.html#code-of-conduct">the project code of conduct</a></div>
      <br class="clear"/>
    </div>
  </body>
</html>
