<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
  <!--
        This file is autogenerated from docs/coding-style.rst
        Do not edit this file. Changes will be lost.
      -->
  <!--
        This page was generated at Wed Apr 19 07:14:27 2023 UTC.
      -->
  <head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <link rel="stylesheet" type="text/css" href="css/main.css"/>
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/>
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/>
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/>
    <link rel="manifest" href="/manifest.json"/>
    <meta name="theme-color" content="#ffffff"/>
    <title>libvirt: Coding style</title>
    <meta name="description" content="libvirt, virtualization, virtualization API"/>
    <script type="text/javascript" src="js/main.js">
      <!--// forces non-empty element-->
    </script>
  </head>
  <body onload="pageload()">
    <div id="body">
      <div class="document" id="coding-style">
<h1>Coding style</h1>

<div class="contents topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#naming-conventions" id="id1">Naming conventions</a></p></li>
<li><p><a class="reference internal" href="#code-indentation" id="id2">Code indentation</a></p></li>
<li><p><a class="reference internal" href="#code-formatting-especially-for-new-code" id="id3">Code formatting (especially for new code)</a></p>
<ul>
<li><p><a class="reference internal" href="#bracket-spacing" id="id4">Bracket spacing</a></p></li>
<li><p><a class="reference internal" href="#commas" id="id5">Commas</a></p></li>
<li><p><a class="reference internal" href="#semicolons" id="id6">Semicolons</a></p></li>
<li><p><a class="reference internal" href="#curly-braces" id="id7">Curly braces</a></p></li>
<li><p><a class="reference internal" href="#conditional-expressions" id="id8">Conditional expressions</a></p></li>
<li><p><a class="reference internal" href="#preprocessor" id="id9">Preprocessor</a></p></li>
<li><p><a class="reference internal" href="#c-types" id="id10">C types</a></p>
<ul>
<li><p><a class="reference internal" href="#scalars" id="id11">Scalars</a></p></li>
<li><p><a class="reference internal" href="#pointers" id="id12">Pointers</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#defining-local-variables" id="id13">Defining Local Variables</a></p></li>
<li><p><a class="reference internal" href="#attribute-annotations" id="id14">Attribute annotations</a></p></li>
<li><p><a class="reference internal" href="#file-handling" id="id15">File handling</a></p></li>
<li><p><a class="reference internal" href="#string-comparisons" id="id16">String comparisons</a></p></li>
<li><p><a class="reference internal" href="#string-copying" id="id17">String copying</a></p></li>
<li><p><a class="reference internal" href="#variable-length-string-buffer" id="id18">Variable length string buffer</a></p></li>
<li><p><a class="reference internal" href="#include-files" id="id19">Include files</a></p></li>
<li><p><a class="reference internal" href="#printf-style-functions" id="id20">Printf-style functions</a></p></li>
<li><p><a class="reference internal" href="#error-message-format" id="id21">Error message format</a></p></li>
<li><p><a class="reference internal" href="#use-of-goto" id="id22">Use of goto</a></p></li>
<li><p><a class="reference internal" href="#xml-element-and-attribute-naming" id="id23">XML element and attribute naming</a></p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="naming-conventions">
<h1><a class="toc-backref" href="#id1">Naming conventions</a><a class="headerlink" href="#naming-conventions" title="Link to this headline">¶</a></h1>
<p>When reading libvirt code, a number of different naming
conventions will be evident due to various changes in thinking
over the course of the project's lifetime. The conventions
documented below should be followed when creating any entirely new
files in libvirt. When working on existing files, while it is
desirable to apply these conventions, keeping a consistent style
with existing code in that particular file is generally more
important. The overall guiding principal is that every file, enum,
struct, function, macro and typedef name must have a 'vir' or
'VIR' prefix. All local scope variable names are exempt, and
global variables are exempt, unless exported in a header file.</p>
<dl>
<dt>File names</dt>
<dd><p>File naming varies depending on the subdirectory. The preferred
style is to have a 'vir' prefix, followed by a name which
matches the name of the functions / objects inside the file.
For example, a file containing an object 'virHashtable' is
stored in files 'virhashtable.c' and 'virhashtable.h'.
Sometimes, methods which would otherwise be declared 'static'
need to be exported for use by a test suite. For this purpose a
second header file should be added with a suffix of 'priv',
e.g. 'virhashtablepriv.h'. Use of underscores in file names is
discouraged when using the 'vir' prefix style. The 'vir' prefix
naming applies to src/util, src/rpc and tests/ directories.
Most other directories do not follow this convention.</p>
</dd>
<dt>Enum type &amp; field names</dt>
<dd><p>All enums should have a 'vir' prefix in their typedef name, and
each following word should have its first letter in uppercase.
The enum name should match the typedef name with a leading
underscore. The enum member names should be in all uppercase,
and use an underscore to separate each word. The enum member
name prefix should match the enum typedef name.</p>
<pre class="literal-block">typedef enum _virSocketType virSocketType;
enum _virSocketType {
    VIR_SOCKET_TYPE_IPV4,
    VIR_SOCKET_TYPE_IPV6,
};</pre>
</dd>
<dt>Struct type names</dt>
<dd><p>All structs should have a 'vir' prefix in their typedef name,
and each following word should have its first letter in
uppercase. The struct name should be the same as the typedef
name with a leading underscore. For types that are part of the
public API, a second typedef should be given for a pointer to
the struct with a 'Ptr' suffix. Do not introduce new such
typedefs for internal types.</p>
<pre class="literal-block">typedef struct _virSomeType virSomeType;
typedef virSomeType *virSomeTypePtr;
struct _virSomeType {
    ...
};</pre>
</dd>
<dt>Function names</dt>
<dd><p>All functions should have a 'vir' prefix in their name,
followed by one or more words with first letter of each word
capitalized. Underscores should not be used in function names.
If the function is operating on an object, then the function
name prefix should match the object typedef name, otherwise it
should match the filename. Following this comes the verb /
action name, and finally an optional subject name. For example,
given an object 'virSomeType', all functions should have a
name 'virSomeType$VERB' or 'virSomeType$VERB$SUBJECT", e.g.
'virHashTableLookup' or 'virHashTableGetValue'.</p>
</dd>
<dt>Macro names</dt>
<dd><p>All macros should have a "VIR" prefix in their name, followed
by one or more uppercase words separated by underscores. The
macro argument names should be in lowercase. Aside from having
a "VIR" prefix there are no common practices for the rest of
the macro name.</p>
</dd>
</dl>
</div>
<div class="section" id="code-indentation">
<h1><a class="toc-backref" href="#id2">Code indentation</a><a class="headerlink" href="#code-indentation" title="Link to this headline">¶</a></h1>
<p>Libvirt's C source code generally adheres to some basic
code-formatting conventions. The existing code base is not totally
consistent on this front, but we do prefer that contributed code
be formatted similarly. In short, use spaces-not-TABs for
indentation, use 4 spaces for each indentation level, and other
than that, follow the K&amp;R style.</p>
<p>If you use Emacs, the project includes a file .dir-locals.el that
sets up the preferred indentation. If you use vim, append the
following to your ~/.vimrc file:</p>
<pre class="literal-block">set nocompatible
filetype on
set autoindent
set smartindent
set cindent
set tabstop=8
set shiftwidth=4
set expandtab
set cinoptions=(0,:0,l1,t0,L3
filetype plugin indent on
au FileType make setlocal noexpandtab
au BufRead,BufNewFile *.am setlocal noexpandtab
match ErrorMsg /\s\+$\| \+\ze\t/</pre>
<p>Or if you don't want to mess your ~/.vimrc up, you can save the
above into a file called .lvimrc (not .vimrc) located at the root
of libvirt source, then install a vim script from
<a class="reference external" href="https://www.vim.org/scripts/script.php?script_id=1408">https://www.vim.org/scripts/script.php?script_id=1408</a>, which will
load the .lvimrc only when you edit libvirt code.</p>
</div>
<div class="section" id="code-formatting-especially-for-new-code">
<h1><a class="toc-backref" href="#id3">Code formatting (especially for new code)</a><a class="headerlink" href="#code-formatting-especially-for-new-code" title="Link to this headline">¶</a></h1>
<p>With new code, we can be even more strict. Please apply the
following function (using GNU indent) to any new code. Note that
this also gives you an idea of the type of spacing we prefer
around operators and keywords:</p>
<pre class="literal-block">indent-libvirt()
{
  indent -bad -bap -bbb -bli4 -br -ce -brs -cs -i4 -l100 -lc100 \
         -sbi4 -psl -saf -sai -saw -sbi4 -ss -sc -cdw -cli4 -npcs -nbc \
         --no-tabs "$@"
}</pre>
<p>Note that sometimes you'll have to post-process that output
further, by piping it through <span class="docutils literal">expand <span class="pre">-i</span></span>, since some leading
TABs can get through. Usually they're in macro definitions or
strings, and should be converted anyhow.</p>
<p>The maximum permitted line length is 100 characters, but lines
should aim to be approximately 80 characters.</p>
<p>Libvirt requires a C99 compiler for various reasons. However, most
of the code base prefers to stick to C89 syntax unless there is a
compelling reason otherwise. For example, it is preferable to use
<span class="docutils literal">/* */</span> comments rather than <span class="docutils literal">//</span>. Also, when declaring local
variables, the prevailing style has been to declare them at the
beginning of a scope, rather than immediately before use.</p>
<div class="section" id="bracket-spacing">
<h2><a class="toc-backref" href="#id4">Bracket spacing</a><a class="headerlink" href="#bracket-spacing" title="Link to this headline">¶</a></h2>
<p>The keywords <span class="docutils literal">if</span>, <span class="docutils literal">for</span>, <span class="docutils literal">while</span>, and <span class="docutils literal">switch</span> must have
a single space following them before the opening bracket. E.g.</p>
<pre class="literal-block">if(foo)   // Bad
if (foo)  // Good</pre>
<p>Function implementations must <strong>not</strong> have any whitespace between
the function name and the opening bracket. E.g.</p>
<pre class="literal-block">int foo (int wizz)  // Bad
int foo(int wizz)   // Good</pre>
<p>Function calls must <strong>not</strong> have any whitespace between the
function name and the opening bracket. E.g.</p>
<pre class="literal-block">bar = foo (wizz);  // Bad
bar = foo(wizz);   // Good</pre>
<p>Function typedefs must <strong>not</strong> have any whitespace between the
closing bracket of the function name and opening bracket of the
arg list. E.g.</p>
<pre class="literal-block">typedef int (*foo) (int wizz);  // Bad
typedef int (*foo)(int wizz);   // Good</pre>
<p>There must not be any whitespace immediately following any opening
bracket, or immediately prior to any closing bracket. E.g.</p>
<pre class="literal-block">int foo( int wizz );  // Bad
int foo(int wizz);    // Good</pre>
</div>
<div class="section" id="commas">
<h2><a class="toc-backref" href="#id5">Commas</a><a class="headerlink" href="#commas" title="Link to this headline">¶</a></h2>
<p>Commas should always be followed by a space or end of line, and
never have leading space; this is enforced during 'make
syntax-check'.</p>
<pre class="literal-block">call(a,b ,c);// Bad
call(a, b, c); // Good</pre>
<p>When declaring an enum or using a struct initializer that occupies
more than one line, use a trailing comma. That way, future edits
to extend the list only have to add a line, rather than modify an
existing line to add the intermediate comma. Any sentinel
enumerator value with a name ending in _LAST is exempt, since you
would extend such an enum before the _LAST element. Another
reason to favor trailing commas is that it requires less effort to
produce via code generators. Note that the syntax checker is
unable to enforce a style of trailing commas, so there are
counterexamples in existing code which do not use it; also, while
C99 allows trailing commas, remember that JSON and XDR do not.</p>
<pre class="literal-block">enum {
    VALUE_ONE,
    VALUE_TWO // Bad
};
enum {
    VALUE_THREE,
    VALUE_FOUR, // Good
};</pre>
</div>
<div class="section" id="semicolons">
<h2><a class="toc-backref" href="#id6">Semicolons</a><a class="headerlink" href="#semicolons" title="Link to this headline">¶</a></h2>
<p>Semicolons should never have a space beforehand. Inside the
condition of a <span class="docutils literal">for</span> loop, there should always be a space or
line break after each semicolon, except for the special case of an
infinite loop (although more infinite loops use <span class="docutils literal">while</span>). While
not enforced, loop counters generally use post-increment.</p>
<pre class="literal-block">for (i = 0 ;i &lt; limit ; ++i) { // Bad
for (i = 0; i &lt; limit; i++) { // Good
for (;;) { // ok
while (1) { // Better</pre>
<p>Empty loop bodies are better represented with curly braces and a
comment, although use of a semicolon is not currently rejected.</p>
<pre class="literal-block">while ((rc = waitpid(pid, &amp;st, 0) == -1) &amp;&amp;
       errno == EINTR); // ok
while ((rc = waitpid(pid, &amp;st, 0) == -1) &amp;&amp;
       errno == EINTR) { // Better
    /* nothing */
}</pre>
</div>
<div class="section" id="curly-braces">
<h2><a class="toc-backref" href="#id7">Curly braces</a><a class="headerlink" href="#curly-braces" title="Link to this headline">¶</a></h2>
<p>Curly braces around an <span class="docutils literal">if</span>, <span class="docutils literal">while</span>, <span class="docutils literal">for</span> etc. can be omitted if the
body and the condition itself occupy only a single line.
In every other case we require the braces. This
ensures that it is trivially easy to identify a
single-<em>statement</em> loop: each has only one <em>line</em> in its body.</p>
<pre class="literal-block">while (expr)             // single line body; {} is optional
    single_line_stmt();</pre>
<pre class="literal-block">while (expr(arg1,
            arg2))      // indentation makes it obvious it is single line,
    single_line_stmt(); // {} is optional (not enforced either way)</pre>
<pre class="literal-block">while (expr1 &amp;&amp;
       expr2) {         // multi-line, at same indentation, {} required
    single_line_stmt();
}</pre>
<p>However, the moment your loop/if/else body extends on to a second
line, for whatever reason (even if it's just an added comment),
then you should add braces. Otherwise, it would be too easy to
insert a statement just before that comment (without adding
braces), thinking it is already a multi-statement loop:</p>
<pre class="literal-block">while (true) // BAD! multi-line body with no braces
    /* comment... */
    single_line_stmt();</pre>
<p>Do this instead:</p>
<pre class="literal-block">while (true) { // Always put braces around a multi-line body.
    /* comment... */
    single_line_stmt();
}</pre>
<p>There is one exception: when the second body line is not at the
same indentation level as the first body line:</p>
<pre class="literal-block">if (expr)
    die("a diagnostic that would make this line"
        " extend past the 80-column limit"));</pre>
<p>It is safe to omit the braces in the code above, since the
further-indented second body line makes it obvious that this is
still a single-statement body.</p>
<p>To reiterate, don't do this:</p>
<pre class="literal-block">if (expr)            // BAD: no braces around...
    while (expr_2) { // ... a multi-line body
        ...
    }</pre>
<p>Do this, instead:</p>
<pre class="literal-block">if (expr) {
    while (expr_2) {
        ...
    }
}</pre>
<p>However, there is one exception in the other direction, when even
a one-line block should have braces. That occurs when that
one-line, brace-less block is an <span class="docutils literal">if</span> or <span class="docutils literal">else</span> block, and the
counterpart block <strong>does</strong> use braces. In that case, put braces
around both blocks. Also, if the <span class="docutils literal">else</span> block is much shorter
than the <span class="docutils literal">if</span> block, consider negating the <span class="docutils literal">if</span>-condition and
swapping the bodies, putting the short block first and making the
longer, multi-line block be the <span class="docutils literal">else</span> block.</p>
<pre class="literal-block">if (expr) {
    ...
    ...
}
else
    x = y;    // BAD: braceless "else" with braced "then",
              // and short block last

if (expr)
    x = y;    // BAD: braceless "if" with braced "else"
else {
    ...
    ...
}</pre>
<p>Keeping braces consistent and putting the short block first is
preferred, especially when the multi-line body is more than a few
lines long, because it is easier to read and grasp the semantics
of an if-then-else block when the simpler block occurs first,
rather than after the more involved block:</p>
<pre class="literal-block">if (!expr) {
  x = y; // putting the smaller block first is more readable
} else {
    ...
    ...
}</pre>
<p>But if negating a complex condition is too ugly, then at least add
braces:</p>
<pre class="literal-block">if (complex expr not worth negating) {
    ...
    ...
} else {
    x = y;
}</pre>
<p>Use hanging braces for compound statements: the opening brace of a
compound statement should be on the same line as the condition
being tested. Only top-level function bodies, nested scopes, and
compound structure declarations should ever have { on a line by
itself.</p>
<pre class="literal-block">void
foo(int a, int b)
{                          // correct - function body
    int 2d[][] = {
      {                    // correct - complex initialization
        1, 2,
      },
    };
    if (a)
    {                      // BAD: compound brace on its own line
        do_stuff();
    }
    {                      // correct - nested scope
        int tmp;
        if (a &lt; b) {       // correct - hanging brace
            tmp = b;
            b = a;
            a = tmp;
        }
    }
}</pre>
</div>
<div class="section" id="conditional-expressions">
<h2><a class="toc-backref" href="#id8">Conditional expressions</a><a class="headerlink" href="#conditional-expressions" title="Link to this headline">¶</a></h2>
<p>For readability reasons new code should avoid shortening
comparisons to 0 for numeric types:</p>
<pre class="literal-block">size nfoos = 0;

GOOD:
  if (nfoos != 0)
  if (nfoos == 0)

BAD:
  if (nfoos)
  if (!nfoos)</pre>
<p>Prefer the shortened version for boolean values. Boolean values
should never be compared against the literal <span class="docutils literal">true</span>, as a
logical non-false value need not be <span class="docutils literal">1</span>.</p>
<pre class="literal-block">bool hasFoos = false;

GOOD:
  if (hasFoos)
  if (!hasFoos)

BAD:
  if (hasFoos == true)
  if (hasFoos != false)
  if (hasFoos == false)
  if (hasFoos != true)</pre>
<p>Pointer comparisons may be shortened. All long forms are okay.</p>
<pre class="literal-block">virFoo *foo = NULL;

GOOD:
  if (foo)                 # or: if (foo != NULL)
  if (!foo)                # or: if (foo == NULL)</pre>
<p>New code should avoid the ternary operator as much as possible.
Specifically it must never span more than one line or nest:</p>
<pre class="literal-block">BAD:
  char *foo = baz ?
              virDoSomethingReallyComplex(driver, vm, something, baz-&gt;foo) :
              NULL;

  char *foo = bar ? bar-&gt;baz ? bar-&gt;baz-&gt;foo : "nobaz" : "nobar";</pre>
</div>
<div class="section" id="preprocessor">
<h2><a class="toc-backref" href="#id9">Preprocessor</a><a class="headerlink" href="#preprocessor" title="Link to this headline">¶</a></h2>
<p>Macros defined with an ALL_CAPS name should generally be assumed
to be unsafe with regards to arguments with side-effects (that is,
MAX(a++, b--) might increment a or decrement b too many or too few
times). Exceptions to this rule are explicitly documented for
macros in viralloc.h and virstring.h.</p>
<p>For variadic macros, stick with C99 syntax:</p>
<pre class="literal-block">#define vshPrint(_ctl, ...) fprintf(stdout, __VA_ARGS__)</pre>
<p>Use parenthesis when checking if a macro is defined, and use
indentation to track nesting:</p>
<pre class="literal-block">#if defined(WITH_POSIX_FALLOCATE) &amp;&amp; !defined(WITH_FALLOCATE)
# define fallocate(a, ignored, b, c) posix_fallocate(a, b, c)
#endif</pre>
</div>
<div class="section" id="c-types">
<h2><a class="toc-backref" href="#id10">C types</a><a class="headerlink" href="#c-types" title="Link to this headline">¶</a></h2>
<p>Use the right type.</p>
<div class="section" id="scalars">
<h3><a class="toc-backref" href="#id11">Scalars</a><a class="headerlink" href="#scalars" title="Link to this headline">¶</a></h3>
<ul class="simple">
<li><p>If you're using <span class="docutils literal">int</span> or <span class="docutils literal">long</span>, odds are good that there's
a better type.</p></li>
<li><p>If a variable is counting something, be sure to declare it with
an unsigned type.</p></li>
<li><p>If it's memory-size-related, use <span class="docutils literal">size_t</span> (use <span class="docutils literal">ssize_t</span>
only if required).</p></li>
<li><p>If it's file-size related, use uintmax_t, or maybe <span class="docutils literal">off_t</span>.</p></li>
<li><p>If it's file-offset related (i.e., signed), use <span class="docutils literal">off_t</span>.</p></li>
<li><p>If it's just counting small numbers use <span class="docutils literal">unsigned int</span>; (on
all but oddball embedded systems, you can assume that that type
is at least four bytes wide).</p></li>
<li><p>If a variable has boolean semantics, give it the <span class="docutils literal">bool</span> type
and use the corresponding <span class="docutils literal">true</span> and <span class="docutils literal">false</span> macros.</p></li>
<li><p>In the unusual event that you require a specific width, use a
standard type like <span class="docutils literal">int32_t</span>, <span class="docutils literal">uint32_t</span>, <span class="docutils literal">uint64_t</span>,
etc.</p></li>
<li><p>While using <span class="docutils literal">bool</span> is good for readability, it comes with a
minor caveat: Don't use <span class="docutils literal">bool</span> in places where the type size
must be constant across all systems, like public interfaces and
on-the-wire protocols. Note that it would be possible (albeit
wasteful) to use <span class="docutils literal">bool</span> in libvirt's logical wire protocol,
since XDR maps that to its lower-level <span class="docutils literal">bool_t</span> type, which
<strong>is</strong> fixed-size.</p></li>
</ul>
<p>Of course, take all of the above with a grain of salt. If you're
about to use some system interface that requires a type like
<span class="docutils literal">size_t</span>, <span class="docutils literal">pid_t</span> or <span class="docutils literal">off_t</span>, use matching types for any
corresponding variables.</p>
<p>Also, if you try to use e.g., <span class="docutils literal">unsigned int</span> as a type, and that
conflicts with the signedness of a related variable, sometimes
it's best just to use the <strong>wrong</strong> type, if <em>pulling the thread</em>
and fixing all related variables would be too invasive.</p>
<p>Finally, while using descriptive types is important, be careful
not to go overboard. If whatever you're doing causes warnings, or
requires casts, then reconsider or ask for help.</p>
</div>
<div class="section" id="pointers">
<h3><a class="toc-backref" href="#id12">Pointers</a><a class="headerlink" href="#pointers" title="Link to this headline">¶</a></h3>
<p>Ensure that all of your pointers are <em>const-correct</em>. Unless a
pointer is used to modify the pointed-to storage, give it the
<span class="docutils literal">const</span> attribute. That way, the reader knows up-front that this
is a read-only pointer. Perhaps more importantly, if we're
diligent about this, when you see a non-const pointer, you're
guaranteed that it is used to modify the storage it points to, or
it is aliased to another pointer that is.</p>
</div>
</div>
<div class="section" id="defining-local-variables">
<h2><a class="toc-backref" href="#id13">Defining Local Variables</a><a class="headerlink" href="#defining-local-variables" title="Link to this headline">¶</a></h2>
<p>Always define local variables at the top of the block in which they
are used (before any pure code). Although modern C compilers allow
defining a local variable in the middle of a block of code, this
practice can lead to bugs, and must be avoided in all libvirt
code. As indicated in these examples, it is okay to initialize
variables where they are defined, even if the initialization involves
calling another function.</p>
<pre class="literal-block">GOOD:
  int
  bob(char *loblaw)
  {
      int x;
      int y = lawBlog();
      char *z = NULL;

      x = y + 20;
      ...
  }

BAD:
  int
  bob(char *loblaw)
  {
      int x;
      int y = lawBlog();

      x = y + 20;

      char *z = NULL; // &lt;===
      ...
  }</pre>
<p>Prefer variable definitions on separate lines. This allows for smaller,
easier to understand diffs when changing them. Define variables in the
smallest possible scope.</p>
<pre class="literal-block">GOOD:
  int count = 0;
  int nnodes;

BAD:
  int count = 0, nnodes;</pre>
</div>
<div class="section" id="attribute-annotations">
<h2><a class="toc-backref" href="#id14">Attribute annotations</a><a class="headerlink" href="#attribute-annotations" title="Link to this headline">¶</a></h2>
<p>Use the following annotations to help the compiler and/or static
analysis tools understand the code better:</p>
<dl class="simple">
<dt><span class="docutils literal">ATTRIBUTE_NONNULL</span></dt>
<dd><p>passing NULL for this parameter is not allowed</p>
</dd>
<dt><span class="docutils literal">ATTRIBUTE_PACKED</span></dt>
<dd><p>force a structure to be packed</p>
</dd>
<dt><span class="docutils literal">G_GNUC_FALLTHROUGH</span></dt>
<dd><p>allow code reuse by multiple switch cases</p>
</dd>
<dt><span class="docutils literal">G_GNUC_NO_INLINE</span></dt>
<dd><p>the function is mocked in the test suite</p>
</dd>
<dt><span class="docutils literal">G_GNUC_NORETURN</span></dt>
<dd><p>the function never returns</p>
</dd>
<dt><span class="docutils literal">G_GNUC_NULL_TERMINATED</span></dt>
<dd><p>last parameter must be NULL</p>
</dd>
<dt><span class="docutils literal">G_GNUC_PRINTF</span></dt>
<dd><p>validate that the formatting string matches parameters</p>
</dd>
<dt><span class="docutils literal">G_GNUC_UNUSED</span></dt>
<dd><p>parameter is unused in this implementation of the function</p>
</dd>
<dt><span class="docutils literal">G_GNUC_WARN_UNUSED_RESULT</span></dt>
<dd><p>the return value must be checked</p>
</dd>
</dl>
</div>
<div class="section" id="file-handling">
<h2><a class="toc-backref" href="#id15">File handling</a><a class="headerlink" href="#file-handling" title="Link to this headline">¶</a></h2>
<p>Usage of the <span class="docutils literal">fdopen()</span>, <span class="docutils literal">close()</span>, <span class="docutils literal">fclose()</span> APIs is
deprecated in libvirt code base to help avoiding double-closing of
files or file descriptors, which is particularly dangerous in a
multi-threaded application. Instead of these APIs, use the macros
from virfile.h</p>
<ul>
<li><p>Open a file from a file descriptor:</p>
<pre class="literal-block">if ((file = VIR_FDOPEN(fd, "r")) == NULL) {
    virReportSystemError(errno, "%s",
                         _("failed to open file from file descriptor"));
    return -1;
}
/* fd is now invalid; only access the file using file variable */</pre>
</li>
<li><p>Close a file descriptor:</p>
<pre class="literal-block">if (VIR_CLOSE(fd) &lt; 0) {
    virReportSystemError(errno, "%s", _("failed to close file"));
}</pre>
</li>
<li><p>Close a file:</p>
<pre class="literal-block">if (VIR_FCLOSE(file) &lt; 0) {
    virReportSystemError(errno, "%s", _("failed to close file"));
}</pre>
</li>
<li><p>Close a file or file descriptor in an error path, without
losing the previous <span class="docutils literal">errno</span> value:</p>
<pre class="literal-block">VIR_FORCE_CLOSE(fd);
VIR_FORCE_FCLOSE(file);</pre>
</li>
</ul>
</div>
<div class="section" id="string-comparisons">
<h2><a class="toc-backref" href="#id16">String comparisons</a><a class="headerlink" href="#string-comparisons" title="Link to this headline">¶</a></h2>
<p>Do not use the strcmp, strncmp, etc functions directly. Instead
use one of the following semantically named macros</p>
<ul>
<li><p>For strict equality:</p>
<pre class="literal-block">STREQ(a,b)
STRNEQ(a,b)</pre>
</li>
<li><p>For case insensitive equality:</p>
<pre class="literal-block">STRCASEEQ(a,b)
STRCASENEQ(a,b)</pre>
</li>
<li><p>For strict equality of a substring:</p>
<pre class="literal-block">STREQLEN(a,b,n)
STRNEQLEN(a,b,n)</pre>
</li>
<li><p>For case insensitive equality of a substring:</p>
<pre class="literal-block">STRCASEEQLEN(a,b,n)
STRCASENEQLEN(a,b,n)</pre>
</li>
<li><p>For strict equality of a prefix:</p>
<pre class="literal-block">STRPREFIX(a,b)</pre>
</li>
<li><p>To avoid having to check if a or b are NULL:</p>
<pre class="literal-block">STREQ_NULLABLE(a, b)
STRNEQ_NULLABLE(a, b)</pre>
</li>
</ul>
</div>
<div class="section" id="string-copying">
<h2><a class="toc-backref" href="#id17">String copying</a><a class="headerlink" href="#string-copying" title="Link to this headline">¶</a></h2>
<p>Do not use the strncpy function. According to the man page, it
does <strong>not</strong> guarantee a NULL-terminated buffer, which makes it
extremely dangerous to use. Instead, use one of the replacement
functions provided by libvirt:</p>
<pre class="literal-block">virStrcpy(char *dest, const char *src, size_t destbytes)</pre>
<p>Use this variant if you know you want to copy the entire src
string into dest.</p>
<pre class="literal-block">virStrcpyStatic(char *dest, const char *src)</pre>
<p>Use this variant if you know you want to copy the entire src
string into dest <strong>and</strong> you know that your destination string is
a static string (i.e. that sizeof(dest) returns something
meaningful). Note that this is a macro, so arguments could be
evaluated more than once.</p>
<pre class="literal-block">dst = g_strdup(src);
dst = g_strndup(src, n);</pre>
<p>You should avoid using strdup or strndup directly as they do not
handle out-of-memory errors, and do not allow a NULL source. Use
<span class="docutils literal">g_strdup</span> and <span class="docutils literal">g_strndup</span> from GLib which abort on OOM and
handle NULL source by returning NULL.</p>
</div>
<div class="section" id="variable-length-string-buffer">
<h2><a class="toc-backref" href="#id18">Variable length string buffer</a><a class="headerlink" href="#variable-length-string-buffer" title="Link to this headline">¶</a></h2>
<p>If there is a need for complex string concatenations, avoid using
the usual sequence of malloc/strcpy/strcat/snprintf functions and
make use of either the
<a class="reference external" href="https://developer.gnome.org/glib/stable/glib-Strings.html">GString</a>
type from GLib or the virBuffer API. If formatting XML or QEMU
command line is needed, use the virBuffer API described in
virbuffer.h, since it has helper functions for those.</p>
<p>Typical usage is as follows:</p>
<pre class="literal-block">char *
somefunction(...)
{
   g_auto(virBuffer) buf = VIR_BUFFER_INITIALIZER;

   ...

   virBufferAddLit(&amp;buf, "&lt;domain&gt;\n");

   ...

   if (some_error)
       return NULL; /* g_auto will free the memory used so far */

   ...

   virBufferAddLit(&amp;buf, "&lt;/domain&gt;\n");

   ...

   if (virBufferCheckError(&amp;buf) &lt; 0)
       return NULL;

   return virBufferContentAndReset(&amp;buf);
}</pre>
</div>
<div class="section" id="include-files">
<h2><a class="toc-backref" href="#id19">Include files</a><a class="headerlink" href="#include-files" title="Link to this headline">¶</a></h2>
<p>There are now quite a large number of include files, both libvirt
internal and external, and system includes. To manage all this
complexity it's best to stick to the following general plan for
all *.c source files:</p>
<pre class="literal-block">/*
 * Copyright notice
 * ....
 * ....
 * ....
 *
 */

#include &lt;config.h&gt;             Must come first in every file.

#include &lt;stdio.h&gt;              Any system includes you need.
#include &lt;string.h&gt;
#include &lt;limits.h&gt;

#if WITH_NUMACTL                Some system includes aren't supported
# include &lt;numa.h&gt;              everywhere so need these #if guards.
#endif

#include "internal.h"           Include this first, after system includes.

#include "util.h"               Any libvirt internal header files.
#include "buf.h"

static int
myInternalFunc()                The actual code.
{
    ...</pre>
<p>Of particular note: <strong>Do not</strong> include libvirt/libvirt.h,
libvirt/virterror.h, libvirt/libvirt-qemu.h, or
libvirt/libvirt-lxc.h. They are included by "internal.h" already
and there are some special reasons why you cannot include these
files explicitly. One of the special cases, "libvirt/libvirt.h" is
included prior to "internal.h" in "remote_protocol.x", to avoid
exposing *_LAST enum elements.</p>
</div>
<div class="section" id="printf-style-functions">
<h2><a class="toc-backref" href="#id20">Printf-style functions</a><a class="headerlink" href="#printf-style-functions" title="Link to this headline">¶</a></h2>
<p>Whenever you add a new printf-style function, i.e., one with a
format string argument and following "..." in its prototype, be
sure to use gcc's printf attribute directive in the prototype. For
example, here's the one for virCommandAddEnvFormat in
vircommand.h:</p>
<pre class="literal-block">void virCommandAddEnvFormat(virCommand *cmd, const char *format, ...)
    G_GNUC_PRINTF(2, 3);</pre>
<p>This makes it so gcc's -Wformat and -Wformat-security options can
do their jobs and cross-check format strings with the number and
types of arguments.</p>
<p>When printing to a string, consider using GString or virBuffer for
incremental allocations, g_strdup_printf for a one-shot
allocation, and g_snprintf for fixed-width buffers. Only use
g_sprintf, if you can prove the buffer won't overflow.</p>
</div>
<div class="section" id="error-message-format">
<h2><a class="toc-backref" href="#id21">Error message format</a><a class="headerlink" href="#error-message-format" title="Link to this headline">¶</a></h2>
<p>Error messages visible to the user should be short and
descriptive. All error messages are translated using gettext and
thus must be wrapped in <span class="docutils literal">_()</span> macro. To simplify the translation
work, the error message must not be concatenated from various
parts. To simplify searching for the error message in the code the
strings should not be broken even if they result into a line
longer than 80 columns and any formatting modifier should be
enclosed by quotes or other obvious separator. If a string used
with <span class="docutils literal">%s</span> can be NULL the NULLSTR macro must be used.</p>
<pre class="literal-block">GOOD: virReportError(VIR_ERR_INTERNAL_ERROR,
                     _("Failed to connect to remote host '%s'"), hostname)

BAD: virReportError(VIR_ERR_INTERNAL_ERROR,
                    _("Failed to %s to remote host '%s'"),
                    "connect", hostname);

BAD: virReportError(VIR_ERR_INTERNAL_ERROR,
                    _("Failed to connect "
                    "to remote host '%s'),
                    hostname);</pre>
</div>
<div class="section" id="use-of-goto">
<h2><a class="toc-backref" href="#id22">Use of goto</a><a class="headerlink" href="#use-of-goto" title="Link to this headline">¶</a></h2>
<p>The use of goto is not forbidden, and goto is widely used
throughout libvirt. While the uncontrolled use of goto will
quickly lead to unmaintainable code, there is a place for it in
well structured code where its use increases readability and
maintainability. In general, if goto is used for error recovery,
it's likely to be ok, otherwise, be cautious or avoid it all
together.</p>
<p>The typical use of goto is to jump to cleanup code in the case of
a long list of actions, any of which may fail and cause the entire
operation to fail. In this case, a function will have a single
label at the end of the function. It's almost always ok to use
this style. In particular, if the cleanup code only involves
free'ing memory, then having multiple labels is overkill. g_free()
and most of the functions named XXXFree() in libvirt is required
to handle NULL as its arg. This does not apply to libvirt's public
APIs. Thus you can safely call free on all the variables even if
they were not yet allocated (yes they have to have been
initialized to NULL). This is much simpler and clearer than having
multiple labels. Note that most of libvirt's type declarations can
be marked with either <span class="docutils literal">g_autofree</span> or <span class="docutils literal">g_autoptr</span> which uses
the compiler's <span class="docutils literal"><span class="pre">__attribute__((cleanup))</span></span> that calls the
appropriate free function when the variable goes out of scope.</p>
<p>There are a couple of signs that a particular use of goto is not
ok:</p>
<ul class="simple">
<li><p>You're using multiple labels. If you find yourself using
multiple labels, you're strongly encouraged to rework your code
to eliminate all but one of them.</p></li>
<li><p>The goto jumps back up to a point above the current line of
code being executed. Please use some combination of looping
constructs to re-execute code instead; it's almost certainly
going to be more understandable by others. One well-known
exception to this rule is restarting an i/o operation following
EINTR.</p></li>
<li><p>The goto jumps down to an arbitrary place in the middle of a
function followed by further potentially failing calls. You
should almost certainly be using a conditional and a block
instead of a goto. Perhaps some of your function's logic would
be better pulled out into a helper function.</p></li>
</ul>
<p>Although libvirt does not encourage the Linux kernel wind/unwind
style of multiple labels, there's a good general discussion of the
issue archived at
<a class="reference external" href="https://web.archive.org/web/20130521051957/http://kerneltrap.org/node/553/2131">KernelTrap</a></p>
<p>When using goto, please use one of these standard labels if it
makes sense:</p>
<pre class="literal-block">error:     A path only taken upon return with an error code
cleanup:   A path taken upon return with success code + optional error
retry:     If needing to jump upwards (e.g., retry on EINTR)</pre>
<p>Top-level labels should be indented by one space (putting them on
the beginning of the line confuses function context detection in
git):</p>
<pre class="literal-block">int foo()
{
    /* ... do stuff ... */
 cleanup:
    /* ... do other stuff ... */
}</pre>
</div>
<div class="section" id="xml-element-and-attribute-naming">
<h2><a class="toc-backref" href="#id23">XML element and attribute naming</a><a class="headerlink" href="#xml-element-and-attribute-naming" title="Link to this headline">¶</a></h2>
<p>New elements and/or attributes should be short and descriptive.
In general, they should reflect what the feature does instead of
how exactly it is named in given hypervisor because this creates
an abstraction that other drivers can benefit from (for instance
if the same feature is named differently in two hypervisors).
That is not to say an element or attribute can't have the same
name as in a hypervisor, but proceed with caution.</p>
<p>Single worded names are preferred, but if more words must be
used then they shall be joined in camelCase style.</p>
</div>
</div>
</div>
    </div>
    <div id="nav">
      <div id="home">
        <a href="index.html">Home</a>
      </div>
      <div id="jumplinks">
        <ul>
          <li>
            <a href="downloads.html">Download</a>
          </li>
          <li>
            <a href="contribute.html">Contribute</a>
          </li>
          <li>
            <a href="docs.html">Docs</a>
          </li>
        </ul>
      </div>
      <div id="search">
        <form id="simplesearch" action="https://www.google.com/search" enctype="application/x-www-form-urlencoded" method="get">
          <div>
            <input id="searchsite" name="sitesearch" type="hidden" value="libvirt.org"/>
            <input id="searchq" name="q" type="text" size="12" value=""/>
            <input name="submit" type="submit" value="Go"/>
          </div>
        </form>
        <div id="advancedsearch">
          <span>
            <input type="radio" name="what" id="whatwebsite" checked="checked" value="website"/>
            <label for="whatwebsite">Website</label>
          </span>
          <span>
            <input type="radio" name="what" id="whatwiki" value="wiki"/>
            <label for="whatwiki">Wiki</label>
          </span>
          <span>
            <input type="radio" name="what" id="whatdevs" value="devs"/>
            <label for="whatdevs">Developers list</label>
          </span>
          <span>
            <input type="radio" name="what" id="whatusers" value="users"/>
            <label for="whatusers">Users list</label>
          </span>
        </div>
      </div>
    </div>
    <div id="footer">
      <div id="contact">
        <h3>Contact</h3>
        <ul>
          <li>
            <a href="contact.html#mailing-lists">email</a>
          </li>
          <li>
            <a href="contact.html#irc">irc</a>
          </li>
        </ul>
      </div>
      <div id="community">
        <h3>Community</h3>
        <ul>
          <li>
            <a href="https://twitter.com/hashtag/libvirt">twitter</a>
          </li>
          <li>
            <a href="https://stackoverflow.com/questions/tagged/libvirt">stackoverflow</a>
          </li>
          <li>
            <a href="https://serverfault.com/questions/tagged/libvirt">serverfault</a>
          </li>
        </ul>
      </div>
      <div id="contribute">
        <h3>Contribute</h3>
        <ul>
          <li>
            <a href="https://gitlab.com/libvirt/libvirt/-/blob/master/docs/coding-style.rst">edit this page</a>
          </li>
        </ul>
      </div>
      <div id="conduct">
            Participants in the libvirt project agree to abide by <a href="governance.html#code-of-conduct">the project code of conduct</a></div>
      <br class="clear"/>
    </div>
  </body>
</html>
