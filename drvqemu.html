<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
  <!--
        This file is autogenerated from docs/drvqemu.rst
        Do not edit this file. Changes will be lost.
      -->
  <!--
        This page was generated at Wed Apr 19 07:14:27 2023 UTC.
      -->
  <head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <link rel="stylesheet" type="text/css" href="css/main.css"/>
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/>
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/>
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/>
    <link rel="manifest" href="/manifest.json"/>
    <meta name="theme-color" content="#ffffff"/>
    <title>libvirt: QEMU/KVM/HVF hypervisor driver</title>
    <meta name="description" content="libvirt, virtualization, virtualization API"/>
    <script type="text/javascript" src="js/main.js">
      <!--// forces non-empty element-->
    </script>
  </head>
  <body onload="pageload()">
    <div id="body">
      <div class="document" id="qemu-kvm-hvf-hypervisor-driver">
<h1>QEMU/KVM/HVF hypervisor driver</h1>

<p>The libvirt KVM/QEMU driver can manage any QEMU emulator from version 3.1.0 or
later.</p>
<p>It supports multiple QEMU accelerators: software
emulation also known as TCG, hardware-assisted virtualization on Linux
with KVM and hardware-assisted virtualization on macOS with
Hypervisor.framework (<span class="since">since 8.1.0</span>).</p>
<div class="contents topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#project-links" id="id1">Project Links</a></p></li>
<li><p><a class="reference internal" href="#deployment-pre-requisites" id="id2">Deployment pre-requisites</a></p></li>
<li><p><a class="reference internal" href="#connections-to-qemu-driver" id="id3">Connections to QEMU driver</a></p>
<ul>
<li><p><a class="reference internal" href="#embedded-driver" id="id4">Embedded driver</a></p>
<ul>
<li><p><a class="reference internal" href="#directory-tree" id="id5">Directory tree</a></p></li>
<li><p><a class="reference internal" href="#api-usage-with-event-loop" id="id6">API usage with event loop</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#location-of-configuration-files" id="id7">Location of configuration files</a></p></li>
<li><p><a class="reference internal" href="#driver-security-architecture" id="id8">Driver security architecture</a></p>
<ul>
<li><p><a class="reference internal" href="#driver-instances" id="id9">Driver instances</a></p></li>
<li><p><a class="reference internal" href="#posix-users-groups" id="id10">POSIX users/groups</a></p></li>
<li><p><a class="reference internal" href="#linux-process-capabilities" id="id11">Linux process capabilities</a></p></li>
<li><p><a class="reference internal" href="#selinux-basic-confinement" id="id12">SELinux basic confinement</a></p></li>
<li><p><a class="reference internal" href="#selinux-svirt-confinement" id="id13">SELinux sVirt confinement</a></p></li>
<li><p><a class="reference internal" href="#apparmor-svirt-confinement" id="id14">AppArmor sVirt confinement</a></p></li>
<li><p><a class="reference internal" href="#cgroups-device-acls" id="id15">Cgroups device ACLs</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#import-and-export-of-libvirt-domain-xml-configs" id="id16">Import and export of libvirt domain XML configs</a></p>
<ul>
<li><p><a class="reference internal" href="#converting-from-qemu-args-to-domain-xml" id="id17">Converting from QEMU args to domain XML</a></p></li>
<li><p><a class="reference internal" href="#converting-from-domain-xml-to-qemu-args" id="id18">Converting from domain XML to QEMU args</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#pass-through-of-arbitrary-qemu-commands" id="id19">Pass-through of arbitrary qemu commands</a></p></li>
<li><p><a class="reference internal" href="#qemu-feature-configuration-for-testing" id="id20">QEMU feature configuration for testing</a></p></li>
<li><p><a class="reference internal" href="#control-of-qemu-deprecation-warnings" id="id21">Control of QEMU deprecation warnings</a></p></li>
<li><p><a class="reference internal" href="#overriding-properties-of-qemu-devices" id="id22">Overriding properties of QEMU devices</a></p></li>
<li><p><a class="reference internal" href="#example-domain-xml-config" id="id23">Example domain XML config</a></p>
<ul>
<li><p><a class="reference internal" href="#qemu-emulated-guest-on-x86-64" id="id24">QEMU emulated guest on x86_64</a></p></li>
<li><p><a class="reference internal" href="#kvm-hardware-accelerated-guest-on-i686" id="id25">KVM hardware accelerated guest on i686</a></p></li>
<li><p><a class="reference internal" href="#hvf-hardware-accelerated-guest-on-x86-64" id="id26">HVF hardware accelerated guest on x86_64</a></p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="project-links">
<h1><a class="toc-backref" href="#id1">Project Links</a><a class="headerlink" href="#project-links" title="Link to this headline">¶</a></h1>
<ul class="simple">
<li><p>The <a class="reference external" href="https://www.linux-kvm.org/">KVM</a> Linux hypervisor</p></li>
<li><p>The <a class="reference external" href="https://wiki.qemu.org/Index.html">QEMU</a> emulator</p></li>
<li><p><a class="reference external" href="https://developer.apple.com/documentation/hypervisor">Hypervisor.framework</a> reference</p></li>
</ul>
</div>
<div class="section" id="deployment-pre-requisites">
<h1><a class="toc-backref" href="#id2">Deployment pre-requisites</a><a class="headerlink" href="#deployment-pre-requisites" title="Link to this headline">¶</a></h1>
<ul class="simple">
<li><p><strong>QEMU emulators</strong>: The driver will probe <span class="docutils literal">/usr/bin</span> for the presence of
<span class="docutils literal">qemu</span>, <span class="docutils literal"><span class="pre">qemu-system-x86_64</span></span>, <span class="docutils literal"><span class="pre">qemu-system-microblaze</span></span>,
<span class="docutils literal"><span class="pre">qemu-system-microblazeel</span></span>, <span class="docutils literal"><span class="pre">qemu-system-mips</span></span>,<span class="docutils literal"><span class="pre">qemu-system-mipsel</span></span>,
<span class="docutils literal"><span class="pre">qemu-system-sparc</span></span>,<span class="docutils literal"><span class="pre">qemu-system-ppc</span></span>. The results of this can be seen
from the capabilities XML output.</p></li>
<li><p><strong>KVM hypervisor</strong>: The driver will probe <span class="docutils literal">/usr/bin</span> for the presence of
<span class="docutils literal"><span class="pre">qemu-kvm</span></span> and <span class="docutils literal">/dev/kvm</span> device node. If both are found, then KVM fully
virtualized, hardware accelerated guests will be available.</p></li>
<li><p><strong>Hypervisor.framework (HVF)</strong>: The driver will probe <span class="docutils literal">sysctl</span> for the
presence of <span class="docutils literal">Hypervisor.framework</span>. If it is found it will be possible to
create hardware accelerated guests.</p></li>
</ul>
</div>
<div class="section" id="connections-to-qemu-driver">
<h1><a class="toc-backref" href="#id3">Connections to QEMU driver</a><a class="headerlink" href="#connections-to-qemu-driver" title="Link to this headline">¶</a></h1>
<p>The libvirt QEMU driver is a multi-instance driver, providing a single system
wide privileged driver (the "system" instance), and per-user unprivileged
drivers (the "session" instance). The URI driver protocol is "qemu". Some
example connection URIs for the libvirt driver are:</p>
<pre class="literal-block">qemu:///session                      (local access to per-user instance)
qemu+unix:///session                 (local access to per-user instance)

qemu:///system                       (local access to system instance)
qemu+unix:///system                  (local access to system instance)
qemu://example.com/system            (remote access, TLS/x509)
qemu+tcp://example.com/system        (remote access, SASl/Kerberos)
qemu+ssh://root@example.com/system   (remote access, SSH tunnelled)</pre>
<div class="section" id="embedded-driver">
<h2><a class="toc-backref" href="#id4">Embedded driver</a><a class="headerlink" href="#embedded-driver" title="Link to this headline">¶</a></h2>
<p>Since 6.1.0 the QEMU driver has experimental support for operating in an
embedded mode. In this scenario, rather than connecting to the libvirtd daemon,
the QEMU driver runs in the client application process directly. To use this the
client application must have registered &amp; be running an instance of the event
loop. To open the driver in embedded mode the app use the new URI path and
specify a virtual root directory under which the driver will create content. The
path to the root directory must be absolute. Passing a relative path results in
an error.</p>
<pre class="literal-block">qemu:///embed?root=/some/dir</pre>
<p>Broadly speaking the range of functionality is intended to be on a par with that
seen when using the traditional system or session libvirt connections to QEMU.
The features will of course differ depending on whether the application using
the embedded driver is running privileged or unprivileged. For example PCI
device assignment or TAP based networking are only available when running
privileged. While the embedded mode is still classed as experimental some
features may change their default settings between releases.</p>
<p>By default if the application uses any APIs associated with secondary drivers,
these will result in a connection being opened to the corresponding driver in
libvirtd. For example, this allows a virtual machine from the embedded QEMU to
connect its NIC to a virtual network or connect its disk to a storage volume.
Some of the secondary drivers will also be able to support running in embedded
mode. Currently this is supported by the secrets driver, to allow for use of VMs
with encrypted disks</p>
<div class="section" id="directory-tree">
<h3><a class="toc-backref" href="#id5">Directory tree</a><a class="headerlink" href="#directory-tree" title="Link to this headline">¶</a></h3>
<p>Under the specified root directory the following locations will be used</p>
<pre class="literal-block">/some/dir
  |
  +- log
  |   |
  |   +- qemu
  |   +- swtpm
  |
  +- etc
  |   |
  |   +- qemu
  |   +- pki
  |       |
  |       +- qemu
  |
  +- run
  |   |
  |   +- qemu
  |   +- swtpm
  |
  +- cache
  |   |
  |   +- qemu
  |
  +- lib
      |
      +- qemu
      +- swtpm</pre>
<p>Note that UNIX domain sockets used for QEMU virtual machines had a maximum
filename length of 108 characters. Bear this in mind when picking a root
directory to avoid risk of exhausting the filename space. The application is
responsible for recursively purging the contents of this directory tree once
they no longer require a connection, though it can also be left intact for reuse
when opening a future connection.</p>
</div>
<div class="section" id="api-usage-with-event-loop">
<h3><a class="toc-backref" href="#id6">API usage with event loop</a><a class="headerlink" href="#api-usage-with-event-loop" title="Link to this headline">¶</a></h3>
<p>To use the QEMU driver in embedded mode the application must register an event
loop with libvirt. Many of the QEMU driver API calls will rely on the event loop
processing data. With this in mind, applications must <strong>NEVER</strong> invoke API calls
from the event loop thread itself, only other threads. Not following this rule
will lead to deadlocks in the API. This restriction was lifted starting from
6.2.0 release, when QMP processing moved to a dedicated thread. However, it is
important to let the event loop run after each API call, even the ones made from
the event loop thread itself.</p>
</div>
</div>
</div>
<div class="section" id="location-of-configuration-files">
<h1><a class="toc-backref" href="#id7">Location of configuration files</a><a class="headerlink" href="#location-of-configuration-files" title="Link to this headline">¶</a></h1>
<p>The QEMU driver comes with sane default values. However, during its
initialization it reads a configuration file which offers system administrator
or an user to override some of that default. The location of the file depends on
the connection URI, as follows:</p>
<table>
<colgroup>
<col style="width: 33%"/>
<col style="width: 67%"/>
</colgroup>
<tbody>
<tr><td><p><span class="docutils literal"><span class="pre">qemu:///system</span></span></p></td>
<td><p><span class="docutils literal">/etc/libvirt/qemu.conf</span></p></td>
</tr>
<tr><td><p><span class="docutils literal"><span class="pre">qemu:///session</span></span></p></td>
<td><p><span class="docutils literal">$XDG_CONFIG_HOME/libvirt/qemu.conf</span></p></td>
</tr>
<tr><td><p><span class="docutils literal"><span class="pre">qemu:///embed</span></span></p></td>
<td><p><span class="docutils literal">$rootdir/etc/qemu.conf</span></p></td>
</tr>
</tbody>
</table>
<p>If <span class="docutils literal">$XDG_CONFIG_HOME</span> is not set in the environment, it defaults to
<span class="docutils literal"><span class="pre">$HOME/.config</span></span>. For the embed URI the <span class="docutils literal">$rootdir</span> represents the specified
root directory from the connection URI.</p>
<p>Please note, that it is very likely that the only qemu.conf file that will exist
after installing libvirt is the <span class="docutils literal">/etc/libvirt/qemu.conf</span>, if users of the
session daemon or the embed driver want to override a built in value, then they
need to create the file before connecting to the respective URI.</p>
</div>
<div class="section" id="driver-security-architecture">
<h1><a class="toc-backref" href="#id8">Driver security architecture</a><a class="headerlink" href="#driver-security-architecture" title="Link to this headline">¶</a></h1>
<p>There are multiple layers to security in the QEMU driver, allowing for
flexibility in the use of QEMU based virtual machines.</p>
<div class="section" id="driver-instances">
<h2><a class="toc-backref" href="#id9">Driver instances</a><a class="headerlink" href="#driver-instances" title="Link to this headline">¶</a></h2>
<p>As explained above there are two ways to access the QEMU driver in libvirt. The
"qemu:///session" family of URIs connect to a libvirtd instance running as the
same user/group ID as the client application. Thus the QEMU instances spawned
from this driver will share the same privileges as the client application. The
intended use case for this driver is desktop virtualization, with virtual
machines storing their disk images in the user's home directory and being
managed from the local desktop login session.</p>
<p>The "qemu:///system" family of URIs connect to a libvirtd instance running as
the privileged system account 'root'. Thus the QEMU instances spawned from this
driver may have much higher privileges than the client application managing
them. The intended use case for this driver is server virtualization, where the
virtual machines may need to be connected to host resources (block, PCI, USB,
network devices) whose access requires elevated privileges.</p>
</div>
<div class="section" id="posix-users-groups">
<h2><a class="toc-backref" href="#id10">POSIX users/groups</a><a class="headerlink" href="#posix-users-groups" title="Link to this headline">¶</a></h2>
<p>In the "session" instance, the POSIX users/groups model restricts QEMU virtual
machines (and libvirtd in general) to only have access to resources with the
same user/group ID as the client application. There is no finer level of
configuration possible for the "session" instances.</p>
<p>In the "system" instance, libvirt releases from 0.7.0 onwards allow control over
the user/group that the QEMU virtual machines are run as. A build of libvirt
with no configuration parameters set will still run QEMU processes as root:root.
It is possible to change this default by using the --with-qemu-user=$USERNAME
and --with-qemu-group=$GROUPNAME arguments to 'configure' during build. It is
strongly recommended that vendors build with both of these arguments set to
'qemu'. Regardless of this build time default, administrators can set a per-host
default setting in the <span class="docutils literal">/etc/libvirt/qemu.conf</span> configuration file via the
<span class="docutils literal"><span class="pre">user=$USERNAME</span></span> and <span class="docutils literal"><span class="pre">group=$GROUPNAME</span></span> parameters. When a non-root user or
group is configured, the libvirt QEMU driver will change uid/gid to match
immediately before executing the QEMU binary for a virtual machine.</p>
<p>If QEMU virtual machines from the "system" instance are being run as non-root,
there will be greater restrictions on what host resources the QEMU process will
be able to access. The libvirtd daemon will attempt to manage permissions on
resources to minimise the likelihood of unintentional security denials, but the
administrator / application developer must be aware of some of the consequences
/ restrictions.</p>
<ul>
<li><p>The directories <span class="docutils literal">/var/run/libvirt/qemu/</span>, <span class="docutils literal">/var/lib/libvirt/qemu/</span> and
<span class="docutils literal">/var/cache/libvirt/qemu/</span> must all have their ownership set to match the
user / group ID that QEMU guests will be run as. If the vendor has set a
non-root user/group for the QEMU driver at build time, the permissions should
be set automatically at install time. If a host administrator customizes
user/group in <span class="docutils literal">/etc/libvirt/qemu.conf</span>, they will need to manually set the
ownership on these directories.</p></li>
<li><p>When attaching USB and PCI devices to a QEMU guest, QEMU will need to access
files in <span class="docutils literal">/dev/bus/usb</span> and <span class="docutils literal">/sys/bus/pci/devices</span> respectively. The
libvirtd daemon will automatically set the ownership on specific devices that
are assigned to a guest at start time. There should not be any need for
administrator changes in this respect.</p></li>
<li><p>Any files/devices used as guest disk images must be accessible to the
user/group ID that QEMU guests are configured to run as. The libvirtd daemon
will automatically set the ownership of the file/device path to the correct
user/group ID. Applications / administrators must be aware though that the
parent directory permissions may still deny access. The directories
containing disk images must either have their ownership set to match the
user/group configured for QEMU, or their UNIX file permissions must have the
'execute/search' bit enabled for 'others'.</p>
<p>The simplest option is the latter one, of just enabling the 'execute/search'
bit. For any directory to be used for storing disk images, this can be
achieved by running the following command on the directory itself, and any
parent directories</p>
<pre class="literal-block">chmod o+x /path/to/directory</pre>
<p>In particular note that if using the "system" instance and attempting to
store disk images in a user home directory, the default permissions on $HOME
are typically too restrictive to allow access.</p>
</li>
</ul>
<p>The libvirt maintainers <strong>strongly recommend against</strong> running QEMU as the root
user/group. This should not be required in most supported usage scenarios, as
libvirt will generally do the right thing to grant QEMU access to files it is
permitted to use when it is running non-root.</p>
</div>
<div class="section" id="linux-process-capabilities">
<h2><a class="toc-backref" href="#id11">Linux process capabilities</a><a class="headerlink" href="#linux-process-capabilities" title="Link to this headline">¶</a></h2>
<p>In versions of libvirt prior to 6.0.0, even if QEMU was configured to run as the
root user / group, libvirt would strip all process capabilities. This meant that
QEMU could only read/write files owned by root, or with open permissions. In
reality, stripping capabilities did not have any security benefit, as it was
trivial to get commands to run in another context with full capabilities, for
example, by creating a cronjob.</p>
<p>Thus since 6.0.0, if QEMU is running as root, it will keep all process
capabilities. Behaviour when QEMU is running non-root is unchanged, it still has
no capabilities.</p>
</div>
<div class="section" id="selinux-basic-confinement">
<h2><a class="toc-backref" href="#id12">SELinux basic confinement</a><a class="headerlink" href="#selinux-basic-confinement" title="Link to this headline">¶</a></h2>
<p>The basic SELinux protection for QEMU virtual machines is intended to protect
the host OS from a compromised virtual machine process. There is no protection
between guests.</p>
<p>In the basic model, all QEMU virtual machines run under the confined domain
<span class="docutils literal">root:system_r:qemu_t</span>. It is required that any disk image assigned to a QEMU
virtual machine is labelled with <span class="docutils literal">system_u:object_r:virt_image_t</span>. In a
default deployment, package vendors/distributor will typically ensure that the
directory <span class="docutils literal">/var/lib/libvirt/images</span> has this label, such that any disk images
created in this directory will automatically inherit the correct labelling. If
attempting to use disk images in another location, the user/administrator must
ensure the directory has be given this requisite label. Likewise physical block
devices must be labelled <span class="docutils literal">system_u:object_r:virt_image_t</span>.</p>
<p>Not all filesystems allow for labelling of individual files. In particular NFS,
VFat and NTFS have no support for labelling. In these cases administrators must
use the 'context' option when mounting the filesystem to set the default label
to <span class="docutils literal">system_u:object_r:virt_image_t</span>. In the case of NFS, there is an
alternative option, of enabling the <span class="docutils literal">virt_use_nfs</span> SELinux boolean.</p>
</div>
<div class="section" id="selinux-svirt-confinement">
<h2><a class="toc-backref" href="#id13">SELinux sVirt confinement</a><a class="headerlink" href="#selinux-svirt-confinement" title="Link to this headline">¶</a></h2>
<p>The SELinux sVirt protection for QEMU virtual machines builds to the basic level
of protection, to also allow individual guests to be protected from each other.</p>
<p>In the sVirt model, each QEMU virtual machine runs under its own confined
domain, which is based on <span class="docutils literal">system_u:system_r:svirt_t:s0</span> with a unique
category appended, eg, <span class="docutils literal">system_u:system_r:svirt_t:s0:c34,c44</span>. The rules are
setup such that a domain can only access files which are labelled with the
matching category level, eg <span class="docutils literal">system_u:object_r:svirt_image_t:s0:c34,c44</span>. This
prevents one QEMU process accessing any file resources that are prevent to
another QEMU process.</p>
<p>There are two ways of assigning labels to virtual machines under sVirt. In the
default setup, if sVirt is enabled, guests will get an automatically assigned
unique label each time they are booted. The libvirtd daemon will also
automatically relabel exclusive access disk images to match this label. Disks
that are marked as &lt;shared&gt; will get a generic label
<span class="docutils literal">system_u:system_r:svirt_image_t:s0</span> allowing all guests read/write access
them, while disks marked as &lt;readonly&gt; will get a generic label
<span class="docutils literal">system_u:system_r:svirt_content_t:s0</span> which allows all guests read-only
access.</p>
<p>With statically assigned labels, the application should include the desired
guest and file labels in the XML at time of creating the guest with libvirt. In
this scenario the application is responsible for ensuring the disk images &amp;
similar resources are suitably labelled to match, libvirtd will not attempt any
relabelling.</p>
<p>If the sVirt security model is active, then the node capabilities XML will
include its details. If a virtual machine is currently protected by the security
model, then the guest XML will include its assigned labels. If enabled at
compile time, the sVirt security model will always be activated if SELinux is
available on the host OS. To disable sVirt, and revert to the basic level of
SELinux protection (host protection only), the <span class="docutils literal">/etc/libvirt/qemu.conf</span> file
can be used to change the setting to <span class="docutils literal"><span class="pre">security_driver="none"</span></span></p>
</div>
<div class="section" id="apparmor-svirt-confinement">
<h2><a class="toc-backref" href="#id14">AppArmor sVirt confinement</a><a class="headerlink" href="#apparmor-svirt-confinement" title="Link to this headline">¶</a></h2>
<p>When using basic AppArmor protection for the libvirtd daemon and QEMU virtual
machines, the intention is to protect the host OS from a compromised virtual
machine process. There is no protection between guests.</p>
<p>The AppArmor sVirt protection for QEMU virtual machines builds on this basic
level of protection, to also allow individual guests to be protected from each
other.</p>
<p>In the sVirt model, if a profile is loaded for the libvirtd daemon, then each
<span class="docutils literal"><span class="pre">qemu:///system</span></span> QEMU virtual machine will have a profile created for it when
the virtual machine is started if one does not already exist. This generated
profile uses a profile name based on the UUID of the QEMU virtual machine and
contains rules allowing access to only the files it needs to run, such as its
disks, pid file and log files. Just before the QEMU virtual machine is started,
the libvirtd daemon will change into this unique profile, preventing the QEMU
process from accessing any file resources that are present in another QEMU
process or the host machine.</p>
<p>The AppArmor sVirt implementation is flexible in that it allows an administrator
to customize the template file in <span class="docutils literal">/etc/apparmor.d/libvirt/TEMPLATE</span> for
site-specific access for all newly created QEMU virtual machines. Also, when a
new profile is generated, two files are created:
<span class="docutils literal"><span class="pre">/etc/apparmor.d/libvirt/libvirt-&lt;uuid&gt;</span></span> and
<span class="docutils literal"><span class="pre">/etc/apparmor.d/libvirt/libvirt-&lt;uuid&gt;.files</span></span>. The former can be fine-tuned
by the administrator to allow custom access for this particular QEMU virtual
machine, and the latter will be updated appropriately when required file access
changes, such as when a disk is added. This flexibility allows for situations
such as having one virtual machine in complain mode with all others in enforce
mode.</p>
<p>While users can define their own AppArmor profile scheme, a typical
configuration will include a profile for <span class="docutils literal">/usr/sbin/libvirtd</span>,
<span class="docutils literal"><span class="pre">/usr/lib/libvirt/virt-aa-helper</span></span> or <span class="docutils literal"><span class="pre">/usr/libexec/virt-aa-helper</span></span>(a
helper program which the libvirtd daemon uses instead of manipulating AppArmor
directly), and an abstraction to be included by
<span class="docutils literal">/etc/apparmor.d/libvirt/TEMPLATE</span> (typically
<span class="docutils literal"><span class="pre">/etc/apparmor.d/abstractions/libvirt-qemu</span></span>). An example profile scheme can be
found in the examples/apparmor directory of the source distribution.</p>
<p>If the sVirt security model is active, then the node capabilities XML will
include its details. If a virtual machine is currently protected by the security
model, then the guest XML will include its assigned profile name. If enabled at
compile time, the sVirt security model will be activated if AppArmor is
available on the host OS and a profile for the libvirtd daemon is loaded when
libvirtd is started. To disable sVirt, and revert to the basic level of AppArmor
protection (host protection only), the <span class="docutils literal">/etc/libvirt/qemu.conf</span> file can be
used to change the setting to <span class="docutils literal"><span class="pre">security_driver="none"</span></span>.</p>
</div>
<div class="section" id="cgroups-device-acls">
<h2><a class="toc-backref" href="#id15">Cgroups device ACLs</a><a class="headerlink" href="#cgroups-device-acls" title="Link to this headline">¶</a></h2>
<p>Linux kernels have a capability known as "cgroups" which is used for resource
management. It is implemented via a number of "controllers", each controller
covering a specific task/functional area. One of the available controllers is
the "devices" controller, which is able to setup access control lists of
block/character devices that a cgroup should be allowed to access. If the
"devices" controller is mounted on a host, then libvirt will automatically
create a dedicated cgroup for each QEMU virtual machine and setup the device
access control list so that the QEMU process can only access shared devices, and
explicitly assigned disks images backed by block devices.</p>
<p>The list of shared devices a guest is allowed access to is</p>
<pre class="literal-block">/dev/null, /dev/full, /dev/zero,
/dev/random, /dev/urandom,
/dev/ptmx, /dev/kvm,</pre>
<p>In the event of unanticipated needs arising, this can be customized via the
<span class="docutils literal">/etc/libvirt/qemu.conf</span> file. To mount the cgroups device controller, the
following command should be run as root, prior to starting libvirtd</p>
<pre class="literal-block">mkdir /dev/cgroup
mount -t cgroup none /dev/cgroup -o devices</pre>
<p>libvirt will then place each virtual machine in a cgroup at
<span class="docutils literal"><span class="pre">/dev/cgroup/libvirt/qemu/$VMNAME/</span></span></p>
</div>
</div>
<div class="section" id="import-and-export-of-libvirt-domain-xml-configs">
<h1><a class="toc-backref" href="#id16">Import and export of libvirt domain XML configs</a><a class="headerlink" href="#import-and-export-of-libvirt-domain-xml-configs" title="Link to this headline">¶</a></h1>
<p>The QEMU driver currently supports a single native config format known as
<span class="docutils literal"><span class="pre">qemu-argv</span></span>. The data for this format is expected to be a single line first a
list of environment variables, then the QEMu binary name, finally followed by
the QEMU command line arguments</p>
<div class="section" id="converting-from-qemu-args-to-domain-xml">
<h2><a class="toc-backref" href="#id17">Converting from QEMU args to domain XML</a><a class="headerlink" href="#converting-from-qemu-args-to-domain-xml" title="Link to this headline">¶</a></h2>
<p><strong>Note:</strong> this operation is <span class="removed">deleted as of 5.5.0</span> and will return an
error.</p>
<p>The <span class="docutils literal">virsh <span class="pre">domxml-from-native</span></span> provides a way to convert an existing set of
QEMU args into a guest description using libvirt Domain XML that can then be
used by libvirt. Please note that this command is intended to be used to convert
existing qemu guests previously started from the command line to be managed
through libvirt. It should not be used a method of creating new guests from
scratch. New guests should be created using an application calling the libvirt
APIs (see the <a class="reference external" href="apps.html">libvirt applications page</a> for some examples) or by
manually crafting XML to pass to virsh.</p>
</div>
<div class="section" id="converting-from-domain-xml-to-qemu-args">
<h2><a class="toc-backref" href="#id18">Converting from domain XML to QEMU args</a><a class="headerlink" href="#converting-from-domain-xml-to-qemu-args" title="Link to this headline">¶</a></h2>
<p>The <span class="docutils literal">virsh <span class="pre">domxml-to-native</span></span> provides a way to convert a guest description
using libvirt Domain XML, into a set of QEMU args that would be used by libvirt
to start the qemu process.</p>
<p>Note that currently the command line formatted by libvirt is no longer suited
for manually running qemu as the configuration expects various resources and
open file descriptors passed to the process which are usually prepared by
libvirtd as well as certain features being configured via the monitor.</p>
<p>The qemu arguments as returned by <span class="docutils literal">virsh <span class="pre">domxml-to-native</span></span> thus are not
trivially usable outside of libvirt.</p>
</div>
</div>
<div class="section" id="pass-through-of-arbitrary-qemu-commands">
<h1><a class="toc-backref" href="#id19">Pass-through of arbitrary qemu commands</a><a class="headerlink" href="#pass-through-of-arbitrary-qemu-commands" title="Link to this headline">¶</a></h1>
<p>Libvirt provides an XML namespace and an optional library <span class="docutils literal"><span class="pre">libvirt-qemu.so</span></span>
for dealing specifically with qemu. When used correctly, these extensions allow
testing specific qemu features that have not yet been ported to the generic
libvirt XML and API interfaces. However, they are <strong>unsupported</strong>, in that the
library is not guaranteed to have a stable API, abusing the library or XML may
result in inconsistent state the crashes libvirtd, and upgrading either qemu-kvm
or libvirtd may break behavior of a domain that was relying on a qemu-specific
pass-through. If you find yourself needing to use them to access a particular
qemu feature, then please post an RFE to the libvirt mailing list to get that
feature incorporated into the stable libvirt XML and API interfaces.</p>
<p>The library provides two API: <span class="docutils literal">virDomainQemuMonitorCommand</span>, for sending an
arbitrary monitor command (in either HMP or QMP format) to a qemu guest (
<span class="since">Since 0.8.3</span> ), and <span class="docutils literal">virDomainQemuAttach</span>, for registering a qemu
domain that was manually started so that it can then be managed by libvirtd (
<span class="since">Since 0.9.4</span> , <span class="removed">removed as of 5.5.0</span> ).</p>
<p>Additionally, the following XML additions allow fine-tuning of the command line
given to qemu when starting a domain ( <span class="since">Since 0.8.3</span> ). In order to use
the XML additions, it is necessary to issue an XML namespace request (the
special <span class="docutils literal">xmlns:name</span> attribute) that pulls in
<span class="docutils literal"><span class="pre">http://libvirt.org/schemas/domain/qemu/1.0</span></span>; typically, the namespace is
given the name of <span class="docutils literal">qemu</span>. With the namespace in place, it is then possible to
add an element <span class="docutils literal">&lt;qemu:commandline&gt;</span> under <span class="docutils literal">domain</span>, with the following
sub-elements repeated as often as needed:</p>
<dl class="simple">
<dt><span class="docutils literal">qemu:arg</span></dt>
<dd><p>Add an additional command-line argument to the qemu process when starting the
domain, given by the value of the attribute <span class="docutils literal">value</span>.</p>
</dd>
<dt><span class="docutils literal">qemu:env</span></dt>
<dd><p>Add an additional environment variable to the qemu process when starting the
domain, given with the name-value pair recorded in the attributes <span class="docutils literal">name</span>
and optional <span class="docutils literal">value</span>.</p>
</dd>
</dl>
<p>Example:</p>
<pre class="literal-block">&lt;domain type='qemu' xmlns:qemu='http://libvirt.org/schemas/domain/qemu/1.0'&gt;
  &lt;name&gt;QEMU-fedora-i686&lt;/name&gt;
  &lt;memory&gt;219200&lt;/memory&gt;
  &lt;os&gt;
    &lt;type arch='i686' machine='pc'&gt;hvm&lt;/type&gt;
  &lt;/os&gt;
  &lt;devices&gt;
    &lt;emulator&gt;/usr/bin/qemu-system-x86_64&lt;/emulator&gt;
  &lt;/devices&gt;
  &lt;qemu:commandline&gt;
    &lt;qemu:arg value='-newarg'/&gt;
    &lt;qemu:env name='QEMU_ENV' value='VAL'/&gt;
  &lt;/qemu:commandline&gt;
&lt;/domain&gt;</pre>
</div>
<div class="section" id="qemu-feature-configuration-for-testing">
<h1><a class="toc-backref" href="#id20">QEMU feature configuration for testing</a><a class="headerlink" href="#qemu-feature-configuration-for-testing" title="Link to this headline">¶</a></h1>
<p>In some cases e.g. when developing a new feature or for testing it may be
required to control a given qemu feature (or qemu capability) to test it before
it's complete or disable it for debugging purposes. <span class="since">Since 5.5.0</span> it's
possible to use the same special qemu namespace as above
(<span class="docutils literal"><span class="pre">http://libvirt.org/schemas/domain/qemu/1.0</span></span>) and use <span class="docutils literal">&lt;qemu:capabilities&gt;</span>
element to add (<span class="docutils literal">&lt;qemu:add <span class="pre">capability="capname"/&gt;</span></span>) or remove
(<span class="docutils literal">&lt;qemu:del <span class="pre">capability="capname"/&gt;</span></span>) capability bits. The naming of the
feature bits is the same libvirt uses in the status XML. Note that this feature
is meant for experiments only and should _not_ be used in production.</p>
<p>Example:</p>
<pre class="literal-block">&lt;domain type='qemu' xmlns:qemu='http://libvirt.org/schemas/domain/qemu/1.0'&gt;
  &lt;name&gt;testvm&lt;/name&gt;

   [...]

  &lt;qemu:capabilities&gt;
    &lt;qemu:add capability='blockdev'/&gt;
    &lt;qemu:del capability='drive'/&gt;
  &lt;/qemu:capabilities&gt;
&lt;/domain&gt;</pre>
</div>
<div class="section" id="control-of-qemu-deprecation-warnings">
<h1><a class="toc-backref" href="#id21">Control of QEMU deprecation warnings</a><a class="headerlink" href="#control-of-qemu-deprecation-warnings" title="Link to this headline">¶</a></h1>
<p>The following knob controls how QEMU behaves towards deprecated commands and
arguments used by libvirt:</p>
<pre class="literal-block">&lt;domain type='qemu' xmlns:qemu='http://libvirt.org/schemas/domain/qemu/1.0'&gt;
  &lt;name&gt;testvm&lt;/name&gt;

   [...]

  &lt;qemu:deprecation behavior='crash'/&gt;</pre>
<p>This setting is meant for developers and CI efforts to make it obvious when
libvirt relies on fields which are deprecated so that it can be fixes as soon
as possible.</p>
<p>Possible options are:</p>
<dl class="simple">
<dt><span class="docutils literal">none</span></dt>
<dd><p>(default) qemu is supposed to accept and output deprecated fields and commands</p>
</dd>
<dt><span class="docutils literal">omit</span></dt>
<dd><p>qemu is instructed to omit deprecated fields on output, behaviour towards
fields and commands from libvirtd is not changed</p>
</dd>
<dt><span class="docutils literal">reject</span></dt>
<dd><p>qemu is instructed to report an error if a deprecated command or field is
used by libvirtd</p>
</dd>
<dt><span class="docutils literal">crash</span></dt>
<dd><p>qemu crashes when an deprecated command or field is used by libvirtd</p>
</dd>
</dl>
<p>For both "reject" and "crash" qemu is instructed to omit any deprecated fields
on output.</p>
<p>The "reject" option is less harsh towards the VMs but some code paths ignore
errors reported by qemu and thus it may not be obvious that a deprecated
command/field was used, thus it's suggested to use the "crash" option instead.</p>
<p>In cases when qemu doesn't support configuring the behaviour this setting is
silently ignored to allow testing older qemu versions without having to
reconfigure libvirtd.</p>
<p><em>DO NOT</em> use in production.</p>
</div>
<div class="section" id="overriding-properties-of-qemu-devices">
<h1><a class="toc-backref" href="#id22">Overriding properties of QEMU devices</a><a class="headerlink" href="#overriding-properties-of-qemu-devices" title="Link to this headline">¶</a></h1>
<p>For development or testing the <span class="docutils literal">&lt;qemu:override&gt;</span> tag allows to override
specific properties of devices instantiated by libvirt.</p>
<p>The <span class="docutils literal">&lt;qemu:device&gt;</span> sub-element groups overrides for a device identified via
the <span class="docutils literal">alias</span> attribute. The alias corresponds to the <span class="docutils literal">&lt;alias <span class="pre">name=''&gt;</span></span>
property of a device. It's strongly recommended to use user-specified aliases
for devices with overridden properties.</p>
<p>Sub element <span class="docutils literal">&lt;qemu:frontend&gt;</span> encapsulates all overrides of properties for the
device frontend and overrides what libvirt formats via <span class="docutils literal"><span class="pre">-device</span></span>.
<span class="since">Since 8.2.0</span>.</p>
<p>The individual properties are overridden by a <span class="docutils literal">&lt;qemu:property&gt;</span> element. The
<span class="docutils literal">name</span> specifies the name of the property to override. In case when libvirt
doesn't configure the property a property with the name is added to the
commandline. The <span class="docutils literal">type</span> attribute specifies a type of the argument used. The
type must correspond with the type that is expected by QEMU. Supported values
for the type attribute are: <span class="docutils literal">string</span>, <span class="docutils literal">number</span>, <span class="docutils literal">bool</span> (allowed values for
<span class="docutils literal">bool</span> are <span class="docutils literal">true</span> and <span class="docutils literal">false</span>) and <span class="docutils literal">remove</span>. The <span class="docutils literal">remove</span> type is
special and instructs libvirt to remove the property without replacement.</p>
<p>The overrides are applied only to initial device configuration passed to QEMU
via the commandline. Later hotplug operations will not apply any modifications.</p>
<p>Configuring override for a device alias which is not used or attempting to
remove a device property which is not formatted by libvirt will cause failure
to startup the VM.</p>
<p><em>Note:</em> The libvirt project doesn't guarantee any form of compatibility and
stability of devices with overridden properties. The domain is tainted when
such configuration is used.</p>
<p>Example:</p>
<pre class="literal-block">&lt;domain type='kvm' xmlns:qemu='http://libvirt.org/schemas/domain/qemu/1.0'&gt;
  &lt;name&gt;testvm&lt;/name&gt;

   [...]

  &lt;qemu:override&gt;
    &lt;qemu:device alias='ua-devalias'&gt;
      &lt;qemu:frontend&gt;
        &lt;qemu:property name='propname1' type='string' value='test'/&gt;
        &lt;qemu:property name='propname2' type='unsigned' value='123'/&gt;
        &lt;qemu:property name='propname2' type='signed' value='-123'/&gt;
        &lt;qemu:property name='propname3' type='bool' value='false'/&gt;
        &lt;qemu:property name='propname4' type='remove'/&gt;
      &lt;/qemu:frontend&gt;
    &lt;/qemu:device&gt;
  &lt;/qemu:override&gt;
&lt;/domain&gt;</pre>
</div>
<div class="section" id="example-domain-xml-config">
<h1><a class="toc-backref" href="#id23">Example domain XML config</a><a class="headerlink" href="#example-domain-xml-config" title="Link to this headline">¶</a></h1>
<div class="section" id="qemu-emulated-guest-on-x86-64">
<h2><a class="toc-backref" href="#id24">QEMU emulated guest on x86_64</a><a class="headerlink" href="#qemu-emulated-guest-on-x86-64" title="Link to this headline">¶</a></h2>
<pre class="literal-block">&lt;domain type='qemu'&gt;
  &lt;name&gt;QEMU-fedora-i686&lt;/name&gt;
  &lt;uuid&gt;c7a5fdbd-cdaf-9455-926a-d65c16db1809&lt;/uuid&gt;
  &lt;memory&gt;219200&lt;/memory&gt;
  &lt;currentMemory&gt;219200&lt;/currentMemory&gt;
  &lt;vcpu&gt;2&lt;/vcpu&gt;
  &lt;os&gt;
    &lt;type arch='i686' machine='pc'&gt;hvm&lt;/type&gt;
    &lt;boot dev='cdrom'/&gt;
  &lt;/os&gt;
  &lt;devices&gt;
    &lt;emulator&gt;/usr/bin/qemu-system-x86_64&lt;/emulator&gt;
    &lt;disk type='file' device='cdrom'&gt;
      &lt;source file='/home/user/boot.iso'/&gt;
      &lt;target dev='hdc'/&gt;
      &lt;readonly/&gt;
    &lt;/disk&gt;
    &lt;disk type='file' device='disk'&gt;
      &lt;source file='/home/user/fedora.img'/&gt;
      &lt;target dev='hda'/&gt;
    &lt;/disk&gt;
    &lt;interface type='network'&gt;
      &lt;source network='default'/&gt;
    &lt;/interface&gt;
    &lt;graphics type='vnc' port='-1'/&gt;
  &lt;/devices&gt;
&lt;/domain&gt;</pre>
</div>
<div class="section" id="kvm-hardware-accelerated-guest-on-i686">
<h2><a class="toc-backref" href="#id25">KVM hardware accelerated guest on i686</a><a class="headerlink" href="#kvm-hardware-accelerated-guest-on-i686" title="Link to this headline">¶</a></h2>
<pre class="literal-block">&lt;domain type='kvm'&gt;
  &lt;name&gt;demo2&lt;/name&gt;
  &lt;uuid&gt;4dea24b3-1d52-d8f3-2516-782e98a23fa0&lt;/uuid&gt;
  &lt;memory&gt;131072&lt;/memory&gt;
  &lt;vcpu&gt;1&lt;/vcpu&gt;
  &lt;os&gt;
    &lt;type arch="i686"&gt;hvm&lt;/type&gt;
  &lt;/os&gt;
  &lt;clock sync="localtime"/&gt;
  &lt;devices&gt;
    &lt;emulator&gt;/usr/bin/qemu-kvm&lt;/emulator&gt;
    &lt;disk type='file' device='disk'&gt;
      &lt;source file='/var/lib/libvirt/images/demo2.img'/&gt;
      &lt;target dev='hda'/&gt;
    &lt;/disk&gt;
    &lt;interface type='network'&gt;
      &lt;source network='default'/&gt;
      &lt;mac address='24:42:53:21:52:45'/&gt;
    &lt;/interface&gt;
    &lt;graphics type='vnc' port='-1' keymap='de'/&gt;
  &lt;/devices&gt;
&lt;/domain&gt;</pre>
</div>
<div class="section" id="hvf-hardware-accelerated-guest-on-x86-64">
<h2><a class="toc-backref" href="#id26">HVF hardware accelerated guest on x86_64</a><a class="headerlink" href="#hvf-hardware-accelerated-guest-on-x86-64" title="Link to this headline">¶</a></h2>
<pre class="literal-block">&lt;domain type='hvf'&gt;
  &lt;name&gt;hvf-demo&lt;/name&gt;
  &lt;uuid&gt;4dea24b3-1d52-d8f3-2516-782e98a23fa0&lt;/uuid&gt;
  &lt;memory&gt;131072&lt;/memory&gt;
  &lt;vcpu&gt;1&lt;/vcpu&gt;
  &lt;os&gt;
    &lt;type arch="x86_64"&gt;hvm&lt;/type&gt;
  &lt;/os&gt;
  &lt;features&gt;
    &lt;acpi/&gt;
  &lt;/features&gt;
  &lt;clock sync="localtime"/&gt;
  &lt;devices&gt;
    &lt;emulator&gt;/usr/local/bin/qemu-system-x86_64&lt;/emulator&gt;
    &lt;controller type='scsi' index='0' model='virtio-scsi'/&gt;
    &lt;disk type='volume' device='disk'&gt;
      &lt;driver name='qemu' type='qcow2'/&gt;
      &lt;source pool='default' volume='myos'/&gt;
      &lt;target bus='scsi' dev='sda'/&gt;
    &lt;/disk&gt;
    &lt;interface type='user'&gt;
      &lt;mac address='24:42:53:21:52:45'/&gt;
      &lt;model type='virtio'/&gt;
    &lt;/interface&gt;
    &lt;graphics type='vnc' port='-1'/&gt;
  &lt;/devices&gt;
&lt;/domain&gt;</pre>
</div>
</div>
</div>
    </div>
    <div id="nav">
      <div id="home">
        <a href="index.html">Home</a>
      </div>
      <div id="jumplinks">
        <ul>
          <li>
            <a href="downloads.html">Download</a>
          </li>
          <li>
            <a href="contribute.html">Contribute</a>
          </li>
          <li>
            <a href="docs.html">Docs</a>
          </li>
        </ul>
      </div>
      <div id="search">
        <form id="simplesearch" action="https://www.google.com/search" enctype="application/x-www-form-urlencoded" method="get">
          <div>
            <input id="searchsite" name="sitesearch" type="hidden" value="libvirt.org"/>
            <input id="searchq" name="q" type="text" size="12" value=""/>
            <input name="submit" type="submit" value="Go"/>
          </div>
        </form>
        <div id="advancedsearch">
          <span>
            <input type="radio" name="what" id="whatwebsite" checked="checked" value="website"/>
            <label for="whatwebsite">Website</label>
          </span>
          <span>
            <input type="radio" name="what" id="whatwiki" value="wiki"/>
            <label for="whatwiki">Wiki</label>
          </span>
          <span>
            <input type="radio" name="what" id="whatdevs" value="devs"/>
            <label for="whatdevs">Developers list</label>
          </span>
          <span>
            <input type="radio" name="what" id="whatusers" value="users"/>
            <label for="whatusers">Users list</label>
          </span>
        </div>
      </div>
    </div>
    <div id="footer">
      <div id="contact">
        <h3>Contact</h3>
        <ul>
          <li>
            <a href="contact.html#mailing-lists">email</a>
          </li>
          <li>
            <a href="contact.html#irc">irc</a>
          </li>
        </ul>
      </div>
      <div id="community">
        <h3>Community</h3>
        <ul>
          <li>
            <a href="https://twitter.com/hashtag/libvirt">twitter</a>
          </li>
          <li>
            <a href="https://stackoverflow.com/questions/tagged/libvirt">stackoverflow</a>
          </li>
          <li>
            <a href="https://serverfault.com/questions/tagged/libvirt">serverfault</a>
          </li>
        </ul>
      </div>
      <div id="contribute">
        <h3>Contribute</h3>
        <ul>
          <li>
            <a href="https://gitlab.com/libvirt/libvirt/-/blob/master/docs/drvqemu.rst">edit this page</a>
          </li>
        </ul>
      </div>
      <div id="conduct">
            Participants in the libvirt project agree to abide by <a href="governance.html#code-of-conduct">the project code of conduct</a></div>
      <br class="clear"/>
    </div>
  </body>
</html>
